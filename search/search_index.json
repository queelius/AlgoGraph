{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AlgoGraph","text":"<p>Immutable graph data structures and algorithms library with optional AlgoTree integration</p> <p>AlgoGraph is a powerful, functional graph library for Python that provides immutable data structures and a comprehensive collection of graph algorithms. Built with principles of immutability and composability, AlgoGraph makes it easy to work with complex graph structures while maintaining code clarity and correctness.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#immutable-data-structures","title":"Immutable Data Structures","text":"<ul> <li>Vertex: Immutable graph vertices with customizable attributes</li> <li>Edge: Immutable directed/undirected edges with weights and attributes</li> <li>Graph: Immutable graph container with efficient operations</li> </ul>"},{"location":"#30-graph-algorithms","title":"30+ Graph Algorithms","text":"<p>Organized into four comprehensive categories:</p> <ul> <li>Traversal: DFS, BFS, topological sort, cycle detection, path finding</li> <li>Shortest Path: Dijkstra, Bellman-Ford, Floyd-Warshall, A* search</li> <li>Connectivity: Connected components, strongly connected components, bipartite checking, bridges, articulation points</li> <li>Spanning Tree: Kruskal's algorithm, Prim's algorithm, MST operations</li> </ul>"},{"location":"#interactive-shell","title":"Interactive Shell","text":"<p>A VFS-like interface for exploring graphs interactively:</p> <ul> <li>Navigate graphs like a file system (<code>cd</code>, <code>ls</code>, <code>pwd</code>)</li> <li>Query paths, components, and neighbors</li> <li>Load and save graphs in JSON format</li> <li>Tab completion and command history</li> <li>Support for absolute paths and quoted vertex names</li> </ul>"},{"location":"#serialization-interoperability","title":"Serialization &amp; Interoperability","text":"<ul> <li>JSON import/export for persistent storage</li> <li>Optional AlgoTree integration for tree-graph conversions</li> <li>Flat dictionary representation for data exchange</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from AlgoGraph import Vertex, Edge, Graph\nfrom AlgoGraph.algorithms import dijkstra, connected_components\n\n# Create vertices\nvertices = {\n    Vertex('A', attrs={'city': 'Boston'}),\n    Vertex('B', attrs={'city': 'New York'}),\n    Vertex('C', attrs={'city': 'Philadelphia'}),\n}\n\n# Create weighted edges\nedges = {\n    Edge('A', 'B', weight=215),  # miles\n    Edge('B', 'C', weight=95),\n    Edge('A', 'C', weight=310),\n}\n\n# Build graph\ngraph = Graph(vertices, edges)\n\n# Find shortest path\ndistances, predecessors = dijkstra(graph, 'A')\nprint(f\"Distance from A to C: {distances['C']} miles\")\n\n# Check connectivity\ncomponents = connected_components(graph)\nprint(f\"Connected components: {len(components)}\")\n</code></pre>"},{"location":"#why-algograph","title":"Why AlgoGraph?","text":""},{"location":"#functional-immutable","title":"Functional &amp; Immutable","text":"<p>AlgoGraph follows functional programming principles with immutable data structures. Every operation returns a new graph, preserving the original. This makes your code easier to reason about and prevents subtle bugs from shared mutable state.</p>"},{"location":"#clean-separation-of-concerns","title":"Clean Separation of Concerns","text":"<p>Graph data structures are separate from algorithms. This composable design lets you easily combine different algorithms and operations while keeping your code modular and testable.</p>"},{"location":"#production-ready","title":"Production Ready","text":"<ul> <li>Comprehensive test coverage</li> <li>Well-documented API</li> <li>Type hints throughout</li> <li>Performance optimized</li> <li>Battle-tested algorithms</li> </ul>"},{"location":"#developer-friendly","title":"Developer Friendly","text":"<ul> <li>Clear, consistent API design</li> <li>Rich examples and cookbook recipes</li> <li>Interactive shell for exploration</li> <li>Helpful error messages</li> <li>Extensive documentation</li> </ul>"},{"location":"#whats-next","title":"What's Next?","text":"<ul> <li>New to AlgoGraph? Start with the Installation Guide and Quick Start</li> <li>Want to learn the concepts? Read the User Guide</li> <li>Looking for specific functionality? Check the API Reference</li> <li>Need examples? Browse the Examples &amp; Cookbook</li> <li>Want to explore interactively? Try the Interactive Shell</li> </ul>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p>AlgoGraph is built on three core principles:</p> <ol> <li>Immutability: All data structures are immutable by default, preventing bugs and enabling safe concurrent operations</li> <li>Composability: Clean separation between data and algorithms allows flexible combination of operations</li> <li>Simplicity: Clear, consistent API that's easy to learn and use correctly</li> </ol> <p>Learn more in the Design &amp; Philosophy section.</p>"},{"location":"#license","title":"License","text":"<p>AlgoGraph is open source software. See the repository for license details.</p>"},{"location":"contributing/","title":"Contributing to AlgoGraph","text":"<p>Thank you for your interest in contributing to AlgoGraph! This guide will help you get started.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#1-set-up-development-environment","title":"1. Set Up Development Environment","text":"<pre><code># Clone the repository\ngit clone https://github.com/released/AlgoGraph.git\ncd AlgoGraph\n\n# Set up PYTHONPATH\nexport PYTHONPATH=/path/to/released:$PYTHONPATH\n\n# Install development dependencies\npip install pytest pytest-cov pytest-benchmark\n</code></pre>"},{"location":"contributing/#2-run-tests","title":"2. Run Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=AlgoGraph\n\n# Run only unit tests\npytest test/\n\n# Run benchmarks\npytest test/ --benchmark-only\n</code></pre>"},{"location":"contributing/#3-make-your-changes","title":"3. Make Your Changes","text":"<p>Follow these guidelines:</p> <ul> <li>Maintain immutability: All data structures should remain immutable</li> <li>Add tests: Include tests for new features or bug fixes</li> <li>Document code: Add docstrings and type hints</li> <li>Follow style: Use consistent style with existing code</li> </ul>"},{"location":"contributing/#code-style","title":"Code Style","text":""},{"location":"contributing/#python-style","title":"Python Style","text":"<p>AlgoGraph follows PEP 8 with these conventions:</p> <pre><code># Use type hints\ndef dijkstra(graph: Graph, source: str) -&gt; Tuple[Dict[str, float], Dict[str, Optional[str]]]:\n    \"\"\"\n    Dijkstra's shortest path algorithm.\n\n    Args:\n        graph: Graph with non-negative edge weights\n        source: Source vertex ID\n\n    Returns:\n        Tuple of (distances, predecessors)\n    \"\"\"\n    ...\n\n# Use descriptive variable names\ndistances = {}  # Good\nd = {}  # Avoid\n\n# Prefer comprehensions where appropriate\nvertices = {Vertex(name) for name in names}\n</code></pre>"},{"location":"contributing/#docstring-format","title":"Docstring Format","text":"<p>Use Google-style docstrings:</p> <pre><code>def example_function(param1: int, param2: str = \"default\") -&gt; bool:\n    \"\"\"\n    Short one-line description.\n\n    Longer description with more details if needed.\n    Can span multiple lines.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ValueError: When something goes wrong\n\n    Example:\n        &gt;&gt;&gt; example_function(42, \"test\")\n        True\n    \"\"\"\n    ...\n</code></pre>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"contributing/#write-comprehensive-tests","title":"Write Comprehensive Tests","text":"<pre><code>def test_vertex_creation():\n    \"\"\"Test basic vertex creation.\"\"\"\n    v = Vertex('A', attrs={'x': 10})\n\n    assert v.id == 'A'\n    assert v.get('x') == 10\n    assert v.get('y') is None\n\ndef test_vertex_immutability():\n    \"\"\"Test that vertices are immutable.\"\"\"\n    v1 = Vertex('A', attrs={'x': 10})\n    v2 = v1.with_attrs(y=20)\n\n    # Original unchanged\n    assert v1.get('y') is None\n    assert v2.get('y') == 20\n    assert v2.get('x') == 10\n</code></pre>"},{"location":"contributing/#test-edge-cases","title":"Test Edge Cases","text":"<pre><code>def test_empty_graph():\n    \"\"\"Test operations on empty graph.\"\"\"\n    g = Graph()\n\n    assert g.vertex_count == 0\n    assert g.edge_count == 0\n    assert not g.has_vertex('A')\n\ndef test_single_vertex():\n    \"\"\"Test graph with single vertex.\"\"\"\n    g = Graph({Vertex('A')})\n\n    assert g.vertex_count == 1\n    assert g.neighbors('A') == set()\n</code></pre>"},{"location":"contributing/#test-performance","title":"Test Performance","text":"<p>Add benchmarks for critical operations:</p> <pre><code>def test_large_graph_creation(benchmark):\n    \"\"\"Benchmark large graph creation.\"\"\"\n    def create_large_graph():\n        vertices = {Vertex(str(i)) for i in range(1000)}\n        edges = {Edge(str(i), str(i+1)) for i in range(999)}\n        return Graph(vertices, edges)\n\n    graph = benchmark(create_large_graph)\n    assert graph.vertex_count == 1000\n</code></pre>"},{"location":"contributing/#adding-new-features","title":"Adding New Features","text":""},{"location":"contributing/#1-new-algorithm","title":"1. New Algorithm","text":"<p>When adding a new algorithm:</p> <pre><code># In AlgoGraph/algorithms/category.py\n\ndef new_algorithm(graph: Graph, param: str) -&gt; Result:\n    \"\"\"\n    Brief description of what the algorithm does.\n\n    Time Complexity: O(...)\n    Space Complexity: O(...)\n\n    Args:\n        graph: Input graph\n        param: Parameter description\n\n    Returns:\n        Description of return value\n\n    Example:\n        &gt;&gt;&gt; from AlgoGraph import Graph, Vertex, Edge\n        &gt;&gt;&gt; g = Graph({Vertex('A'), Vertex('B')}, {Edge('A', 'B')})\n        &gt;&gt;&gt; result = new_algorithm(g, 'A')\n        &gt;&gt;&gt; print(result)\n        ...\n    \"\"\"\n    # Implementation\n    ...\n</code></pre> <p>Don't forget to:</p> <ol> <li>Add to <code>__all__</code> in the module</li> <li>Export from <code>algorithms/__init__.py</code></li> <li>Add tests</li> <li>Update documentation</li> </ol>"},{"location":"contributing/#2-new-data-structure-feature","title":"2. New Data Structure Feature","text":"<p>When adding methods to existing classes:</p> <pre><code>class Graph:\n    def new_method(self, param: ParamType) -&gt; ReturnType:\n        \"\"\"\n        Description of what the method does.\n\n        Args:\n            param: Parameter description\n\n        Returns:\n            Description of return value\n\n        Example:\n            &gt;&gt;&gt; g = Graph(...)\n            &gt;&gt;&gt; result = g.new_method(param)\n            &gt;&gt;&gt; print(result)\n            ...\n        \"\"\"\n        # Maintain immutability!\n        new_vertices = ...\n        new_edges = ...\n        return Graph(new_vertices, new_edges)\n</code></pre>"},{"location":"contributing/#3-new-shell-command","title":"3. New Shell Command","text":"<p>When adding shell commands:</p> <pre><code># In AlgoGraph/shell/commands.py\n\nclass NewCommand(Command):\n    \"\"\"Brief description of command.\"\"\"\n\n    def execute(self, context: GraphContext, args: List[str]) -&gt; CommandResult:\n        # Validate args\n        if not args:\n            return CommandResult(\n                success=False,\n                output=\"\",\n                context=context,\n                error=\"Usage: newcommand &lt;arg&gt;\"\n            )\n\n        # Implement logic\n        result = do_something(context, args[0])\n\n        return CommandResult(\n            success=True,\n            output=result,\n            context=context\n        )\n</code></pre> <p>Then register in <code>shell.py</code>:</p> <pre><code>self.commands = {\n    ...\n    'newcommand': NewCommand,\n}\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#update-documentation","title":"Update Documentation","text":"<p>When adding features, update:</p> <ol> <li>Docstrings: In the code itself</li> <li>User Guide: In <code>docs/user-guide/</code></li> <li>API Reference: In <code>docs/api/</code></li> <li>Examples: Add examples to <code>docs/examples/</code></li> </ol>"},{"location":"contributing/#build-documentation-locally","title":"Build Documentation Locally","text":"<pre><code># Install MkDocs\npip install mkdocs mkdocs-material mkdocstrings\n\n# Build docs\ncd /path/to/AlgoGraph\nmkdocs serve\n\n# Open http://127.0.0.1:8000 in browser\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<pre><code>git checkout -b feature/my-new-feature\n</code></pre>"},{"location":"contributing/#2-make-changes","title":"2. Make Changes","text":"<ul> <li>Write code</li> <li>Add tests</li> <li>Update documentation</li> </ul>"},{"location":"contributing/#3-test-everything","title":"3. Test Everything","text":"<pre><code># Run tests\npytest\n\n# Check coverage\npytest --cov=AlgoGraph --cov-report=html\n\n# Run benchmarks\npytest --benchmark-only\n</code></pre>"},{"location":"contributing/#4-commit-changes","title":"4. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"Add feature: description\"\n</code></pre> <p>Use clear commit messages:</p> <ul> <li><code>Add feature: description</code> - New feature</li> <li><code>Fix bug: description</code> - Bug fix</li> <li><code>Update docs: description</code> - Documentation</li> <li><code>Refactor: description</code> - Code refactoring</li> <li><code>Test: description</code> - Test additions</li> </ul>"},{"location":"contributing/#5-push-and-create-pr","title":"5. Push and Create PR","text":"<pre><code>git push origin feature/my-new-feature\n</code></pre> <p>Then create a pull request on GitHub.</p>"},{"location":"contributing/#code-review","title":"Code Review","text":"<p>Pull requests will be reviewed for:</p> <ul> <li>Correctness: Does it work as intended?</li> <li>Tests: Are there adequate tests?</li> <li>Documentation: Is it documented?</li> <li>Style: Does it follow conventions?</li> <li>Immutability: Are data structures immutable?</li> <li>Performance: Is it reasonably efficient?</li> </ul>"},{"location":"contributing/#areas-for-contribution","title":"Areas for Contribution","text":""},{"location":"contributing/#high-priority","title":"High Priority","text":"<ul> <li>Additional graph algorithms</li> <li>Performance optimizations</li> <li>Documentation improvements</li> <li>Bug fixes</li> </ul>"},{"location":"contributing/#medium-priority","title":"Medium Priority","text":"<ul> <li>More examples and tutorials</li> <li>Shell command improvements</li> <li>Visualization tools</li> <li>Import/export formats</li> </ul>"},{"location":"contributing/#ideas-welcome","title":"Ideas Welcome","text":"<ul> <li>Integration with other libraries</li> <li>Benchmarking suite</li> <li>Additional data structures</li> <li>Your ideas!</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Open an issue on GitHub</li> <li>Check existing documentation</li> <li>Look at similar code in the project</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the same license as the project.</p>"},{"location":"contributing/#thank-you","title":"Thank You!","text":"<p>Your contributions make AlgoGraph better for everyone. Thank you for taking the time to contribute!</p>"},{"location":"api/vertex/","title":"Vertex API Reference","text":"<p>Complete API documentation for the <code>Vertex</code> class.</p>"},{"location":"api/vertex/#class-definition","title":"Class Definition","text":"<pre><code>@dataclass(frozen=True)\nclass Vertex:\n    \"\"\"Immutable graph vertex with attributes.\"\"\"\n    id: str\n    attrs: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"api/vertex/#constructor","title":"Constructor","text":""},{"location":"api/vertex/#vertexid-attrs","title":"<code>Vertex(id, attrs={})</code>","text":"<p>Create a new vertex.</p> <p>Parameters:</p> <ul> <li><code>id</code> (str): Unique identifier for the vertex</li> <li><code>attrs</code> (Dict[str, Any], optional): Dictionary of vertex attributes</li> </ul> <p>Returns: Vertex instance</p> <p>Example:</p> <pre><code>from AlgoGraph import Vertex\n\n# Simple vertex\nv1 = Vertex('A')\n\n# Vertex with attributes\nv2 = Vertex('London', attrs={\n    'population': 9000000,\n    'country': 'UK'\n})\n</code></pre>"},{"location":"api/vertex/#attributes","title":"Attributes","text":""},{"location":"api/vertex/#id","title":"<code>id</code>","text":"<p>Type: <code>str</code> (read-only)</p> <p>The unique identifier of the vertex.</p> <pre><code>v = Vertex('Alice')\nprint(v.id)  # 'Alice'\n</code></pre>"},{"location":"api/vertex/#attrs","title":"<code>attrs</code>","text":"<p>Type: <code>Dict[str, Any]</code> (read-only)</p> <p>Dictionary of vertex attributes. While you can access this dict, you cannot modify it directly due to the frozen dataclass.</p> <pre><code>v = Vertex('A', attrs={'x': 10, 'y': 20})\nprint(v.attrs)  # {'x': 10, 'y': 20}\n</code></pre>"},{"location":"api/vertex/#methods","title":"Methods","text":""},{"location":"api/vertex/#getkey-defaultnone","title":"<code>get(key, default=None)</code>","text":"<p>Get an attribute value by key.</p> <p>Parameters:</p> <ul> <li><code>key</code> (str): Attribute key to look up</li> <li><code>default</code> (Any, optional): Default value if key not found (default: None)</li> </ul> <p>Returns: Attribute value or default</p> <p>Example:</p> <pre><code>v = Vertex('A', attrs={'value': 42})\n\nv.get('value')           # 42\nv.get('missing')         # None\nv.get('missing', 0)      # 0\n</code></pre>"},{"location":"api/vertex/#with_attrskwargs","title":"<code>with_attrs(**kwargs)</code>","text":"<p>Create a new vertex with added or updated attributes.</p> <p>Parameters:</p> <ul> <li><code>**kwargs</code>: Keyword arguments for attributes to add/update</li> </ul> <p>Returns: New Vertex instance with updated attributes</p> <p>Example:</p> <pre><code>v1 = Vertex('A', attrs={'x': 10})\n\nv2 = v1.with_attrs(y=20)\nprint(v2.attrs)  # {'x': 10, 'y': 20}\n\nv3 = v1.with_attrs(x=15, z=30)\nprint(v3.attrs)  # {'x': 15, 'z': 30}\n\n# Original unchanged\nprint(v1.attrs)  # {'x': 10}\n</code></pre>"},{"location":"api/vertex/#without_attrskeys","title":"<code>without_attrs(*keys)</code>","text":"<p>Create a new vertex with specified attributes removed.</p> <p>Parameters:</p> <ul> <li><code>*keys</code> (str): Attribute keys to remove</li> </ul> <p>Returns: New Vertex instance without specified attributes</p> <p>Example:</p> <pre><code>v1 = Vertex('A', attrs={'x': 10, 'y': 20, 'z': 30})\n\nv2 = v1.without_attrs('y')\nprint(v2.attrs)  # {'x': 10, 'z': 30}\n\nv3 = v1.without_attrs('x', 'z')\nprint(v3.attrs)  # {'y': 20}\n\n# Removing non-existent key is safe\nv4 = v1.without_attrs('missing')  # No error\n</code></pre>"},{"location":"api/vertex/#with_idnew_id","title":"<code>with_id(new_id)</code>","text":"<p>Create a new vertex with a different ID (preserves attributes).</p> <p>Parameters:</p> <ul> <li><code>new_id</code> (str): New vertex ID</li> </ul> <p>Returns: New Vertex instance with updated ID</p> <p>Example:</p> <pre><code>v1 = Vertex('A', attrs={'value': 10})\n\nv2 = v1.with_id('B')\nprint(v2.id)     # 'B'\nprint(v2.attrs)  # {'value': 10}\n</code></pre>"},{"location":"api/vertex/#special-methods","title":"Special Methods","text":""},{"location":"api/vertex/#__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed string representation showing ID and attributes.</p> <p>Returns: str</p> <p>Example:</p> <pre><code>v1 = Vertex('A')\nprint(repr(v1))  # Vertex('A')\n\nv2 = Vertex('A', attrs={'x': 10, 'y': 20})\nprint(repr(v2))  # Vertex('A', x=10, y=20)\n</code></pre>"},{"location":"api/vertex/#__str__","title":"<code>__str__()</code>","text":"<p>Simple string representation (just the ID).</p> <p>Returns: str</p> <p>Example:</p> <pre><code>v = Vertex('Alice', attrs={'age': 30})\nprint(str(v))  # 'Alice'\nprint(f\"User: {v}\")  # 'User: Alice'\n</code></pre>"},{"location":"api/vertex/#__hash__","title":"<code>__hash__()</code>","text":"<p>Hash based on vertex ID only (not attributes).</p> <p>Returns: int</p> <p>Example:</p> <pre><code>v1 = Vertex('A', attrs={'x': 1})\nv2 = Vertex('A', attrs={'x': 2})\n\n# Same hash (same ID)\nhash(v1) == hash(v2)  # True\n\n# Can use in sets/dicts\nvertices = {v1, v2}  # Set with one element\n</code></pre>"},{"location":"api/vertex/#__eq__other","title":"<code>__eq__(other)</code>","text":"<p>Equality based on both ID and attributes.</p> <p>Parameters:</p> <ul> <li><code>other</code>: Object to compare with</li> </ul> <p>Returns: bool</p> <p>Example:</p> <pre><code>v1 = Vertex('A', attrs={'x': 1})\nv2 = Vertex('A', attrs={'x': 1})\nv3 = Vertex('A', attrs={'x': 2})\nv4 = Vertex('B', attrs={'x': 1})\n\nv1 == v2  # True (same ID and attrs)\nv1 == v3  # False (same ID, different attrs)\nv1 == v4  # False (different ID)\nv1 == 'A'  # False (different type)\n</code></pre>"},{"location":"api/vertex/#type-annotations","title":"Type Annotations","text":"<p>The Vertex class is fully type-annotated:</p> <pre><code>from typing import Any, Dict\n\nclass Vertex:\n    id: str\n    attrs: Dict[str, Any]\n\n    def get(self, key: str, default: Any = None) -&gt; Any: ...\n    def with_attrs(self, **kwargs) -&gt; 'Vertex': ...\n    def without_attrs(self, *keys: str) -&gt; 'Vertex': ...\n    def with_id(self, new_id: str) -&gt; 'Vertex': ...\n</code></pre>"},{"location":"api/vertex/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/vertex/#creating-vertices-from-data","title":"Creating Vertices from Data","text":"<pre><code># From a list\nnames = ['Alice', 'Bob', 'Charlie']\nvertices = [Vertex(name) for name in names]\n\n# From a dict\ndata = {\n    'Alice': {'age': 30},\n    'Bob': {'age': 25}\n}\nvertices = [\n    Vertex(name, attrs=attrs)\n    for name, attrs in data.items()\n]\n\n# From CSV/database\nimport csv\nwith open('data.csv') as f:\n    reader = csv.DictReader(f)\n    vertices = [\n        Vertex(row['id'], attrs=row)\n        for row in reader\n    ]\n</code></pre>"},{"location":"api/vertex/#transforming-vertices","title":"Transforming Vertices","text":"<pre><code># Add computed attribute\nv1 = Vertex('A', attrs={'value': 10})\nv2 = v1.with_attrs(doubled=v1.get('value') * 2)\n\n# Conditional update\nv = Vertex('A', attrs={'score': 85})\nif v.get('score') &gt; 80:\n    v = v.with_attrs(grade='A')\n\n# Remove sensitive data\nv1 = Vertex('User1', attrs={'name': 'Alice', 'password': 'secret'})\nv2 = v1.without_attrs('password')\n</code></pre>"},{"location":"api/vertex/#batch-operations","title":"Batch Operations","text":"<pre><code># Update many vertices\nvertices = [Vertex(f'v{i}', attrs={'value': i}) for i in range(10)]\n\n# Apply transformation\nupdated = [\n    v.with_attrs(value=v.get('value') * 2)\n    for v in vertices\n]\n\n# Filter by attribute\nhigh_value = [\n    v for v in vertices\n    if v.get('value', 0) &gt; 5\n]\n</code></pre>"},{"location":"api/vertex/#see-also","title":"See Also","text":"<ul> <li>Edge API Reference</li> <li>Graph API Reference</li> <li>Working with Vertices Guide</li> </ul>"},{"location":"design/immutability/","title":"Immutability","text":"<p>Immutability is the cornerstone of AlgoGraph's design. This document explains why we chose immutability and how it benefits your code.</p>"},{"location":"design/immutability/#what-is-immutability","title":"What is Immutability?","text":"<p>Immutable objects cannot be changed after creation. Instead of modifying an object, you create a new one with the desired changes.</p> <pre><code>from AlgoGraph import Vertex\n\n# Create vertex\nv1 = Vertex('A', attrs={'value': 10})\n\n# \"Modify\" it - actually creates new vertex\nv2 = v1.with_attrs(value=20)\n\n# Original unchanged\nprint(v1.get('value'))  # 10\nprint(v2.get('value'))  # 20\n</code></pre>"},{"location":"design/immutability/#why-immutability","title":"Why Immutability?","text":""},{"location":"design/immutability/#1-no-unexpected-side-effects","title":"1. No Unexpected Side Effects","text":"<p>With mutable objects, functions can modify data unexpectedly:</p> <pre><code># Mutable approach (NOT how AlgoGraph works)\ndef bad_add_edge(graph, edge):\n    graph.edges.add(edge)  # Modifies original!\n    return graph\n\ng1 = create_graph()\ng2 = bad_add_edge(g1, edge)\n# g1 was modified - surprise!\n</code></pre> <p>With immutability, the original is always safe:</p> <pre><code># Immutable approach (how AlgoGraph works)\ng1 = Graph(...)\ng2 = g1.add_edge(edge)  # Returns new graph\n# g1 is unchanged - guaranteed!\n</code></pre>"},{"location":"design/immutability/#2-thread-safety","title":"2. Thread Safety","text":"<p>Immutable objects are inherently thread-safe:</p> <pre><code>from concurrent.futures import ThreadPoolExecutor\nfrom AlgoGraph.algorithms import dijkstra, bfs\n\ngraph = load_graph('network.json')\n\n# Safe to use same graph in multiple threads\nwith ThreadPoolExecutor() as executor:\n    future1 = executor.submit(dijkstra, graph, 'A')\n    future2 = executor.submit(bfs, graph, 'B')\n    future3 = executor.submit(connected_components, graph)\n\n# No locks needed - graph can't be modified\nresults = [f.result() for f in [future1, future2, future3]]\n</code></pre>"},{"location":"design/immutability/#3-easier-debugging","title":"3. Easier Debugging","text":"<p>With immutability, data doesn't change unexpectedly:</p> <pre><code># Create graph\ng1 = create_initial_graph()\nprint(f\"Initial: {g1.vertex_count} vertices\")  # 5\n\n# Transform it\ng2 = add_some_vertices(g1)\nprint(f\"After adding: {g2.vertex_count} vertices\")  # 8\n\n# Original still intact for debugging\nprint(f\"Original still: {g1.vertex_count} vertices\")  # 5\n\n# Can compare states\nprint(f\"Added {g2.vertex_count - g1.vertex_count} vertices\")\n</code></pre>"},{"location":"design/immutability/#4-time-travel-undo","title":"4. Time Travel / Undo","text":"<p>Keep history of all states:</p> <pre><code>history = []\n\n# Build graph step by step\ng = Graph()\nhistory.append(g)\n\ng = g.add_vertex(Vertex('A'))\nhistory.append(g)\n\ng = g.add_vertex(Vertex('B'))\nhistory.append(g)\n\ng = g.add_edge(Edge('A', 'B'))\nhistory.append(g)\n\n# \"Undo\" by going back in history\nprevious_state = history[-2]\nprint(f\"Before last operation: {previous_state.edge_count} edges\")\n</code></pre>"},{"location":"design/immutability/#5-referential-transparency","title":"5. Referential Transparency","text":"<p>Same inputs always produce same outputs:</p> <pre><code>from AlgoGraph.algorithms import dijkstra\n\n# Pure function - no side effects\ndistances1, _ = dijkstra(graph, 'A')\ndistances2, _ = dijkstra(graph, 'A')\n\n# Results are always identical\nassert distances1 == distances2\n\n# Graph is unchanged\nassert graph == graph  # Always true\n</code></pre>"},{"location":"design/immutability/#implementation-techniques","title":"Implementation Techniques","text":""},{"location":"design/immutability/#frozen-dataclasses","title":"Frozen Dataclasses","text":"<p>AlgoGraph uses Python's frozen dataclasses:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Vertex:\n    id: str\n    attrs: dict\n\n# Attempts to modify raise errors\nv = Vertex('A', {'x': 1})\nv.id = 'B'  # FrozenInstanceError!\n</code></pre>"},{"location":"design/immutability/#immutable-collections","title":"Immutable Collections","text":"<p>Sets and dicts are copied, not shared:</p> <pre><code>@dataclass(frozen=True)\nclass Graph:\n    vertices: Set[Vertex]\n    edges: Set[Edge]\n\n    def add_vertex(self, vertex):\n        # Create new set (doesn't modify original)\n        new_vertices = self.vertices | {vertex}\n        return Graph(new_vertices, self.edges)\n</code></pre>"},{"location":"design/immutability/#copy-on-write","title":"Copy-on-Write","text":"<p>Only copy what changes:</p> <pre><code>def add_edge(self, edge):\n    # Only vertices and edges change\n    # All other graph properties remain shared\n    new_edges = self.edges | {edge}\n    return Graph(self.vertices, new_edges)\n</code></pre>"},{"location":"design/immutability/#performance-considerations","title":"Performance Considerations","text":""},{"location":"design/immutability/#memory-overhead","title":"Memory Overhead","text":"<p>Immutability can use more memory:</p> <pre><code># Creating many versions\ng1 = Graph(...)\ng2 = g1.add_vertex(v1)  # New graph\ng3 = g2.add_vertex(v2)  # Another new graph\ng4 = g3.add_vertex(v3)  # Yet another new graph\n\n# All four graphs exist in memory\n</code></pre> <p>Mitigation: Python's garbage collector reclaims unused graphs automatically.</p>"},{"location":"design/immutability/#structural-sharing","title":"Structural Sharing","text":"<p>AlgoGraph uses structural sharing to reduce overhead:</p> <pre><code>g1 = Graph(vertices_set, edges_set)\ng2 = g1.add_vertex(new_vertex)\n\n# g2 shares edges with g1 (sets are immutable)\n# Only vertices set is new\n</code></pre>"},{"location":"design/immutability/#when-to-be-careful","title":"When to Be Careful","text":"<p>Large batch operations can be expensive:</p> <pre><code># Inefficient - creates many intermediate graphs\ng = Graph()\nfor i in range(1000):\n    g = g.add_vertex(Vertex(str(i)))\n</code></pre> <p>Better approach:</p> <pre><code># Efficient - create all vertices at once\nvertices = {Vertex(str(i)) for i in range(1000)}\ng = Graph(vertices)\n</code></pre>"},{"location":"design/immutability/#working-with-immutability","title":"Working with Immutability","text":""},{"location":"design/immutability/#building-graphs","title":"Building Graphs","text":"<p>When building large graphs, create collections first:</p> <pre><code># Good - create sets then build graph\nvertices = {Vertex(name) for name in names}\nedges = {Edge(src, tgt, weight=w) for src, tgt, w in edge_data}\ngraph = Graph(vertices, edges)\n\n# Less efficient - many intermediate graphs\ngraph = Graph()\nfor name in names:\n    graph = graph.add_vertex(Vertex(name))\nfor src, tgt, w in edge_data:\n    graph = graph.add_edge(Edge(src, tgt, weight=w))\n</code></pre>"},{"location":"design/immutability/#transforming-graphs","title":"Transforming Graphs","text":"<p>Collect changes then apply:</p> <pre><code># Collect updates\nupdates = {}\nfor v in graph.vertices:\n    if needs_update(v):\n        updates[v.id] = compute_new_attrs(v)\n\n# Apply all at once\nnew_graph = graph\nfor vid, new_attrs in updates.items():\n    v = graph.get_vertex(vid)\n    updated = v.with_attrs(**new_attrs)\n    new_graph = new_graph.update_vertex(updated)\n</code></pre>"},{"location":"design/immutability/#algorithms","title":"Algorithms","text":"<p>Algorithms work with immutable graphs but can use mutable internal state:</p> <pre><code>def dijkstra(graph, source):\n    # Graph is immutable\n    # But algorithm uses mutable data structures internally\n    distances = {}  # Mutable dict (internal)\n    visited = set()  # Mutable set (internal)\n\n    # ... algorithm logic ...\n\n    # Returns immutable result\n    return distances, predecessors\n</code></pre>"},{"location":"design/immutability/#comparison-with-mutable-approaches","title":"Comparison with Mutable Approaches","text":""},{"location":"design/immutability/#networkx-mutable","title":"NetworkX (Mutable)","text":"<pre><code>import networkx as nx\n\n# Mutable graph\nG = nx.Graph()\nG.add_node('A', value=10)\nG.add_edge('A', 'B')\n\n# Modifies in place\nG.nodes['A']['value'] = 20  # Original changed!\n\n# Not thread-safe\n# Need locks for concurrent access\n</code></pre>"},{"location":"design/immutability/#algograph-immutable","title":"AlgoGraph (Immutable)","text":"<pre><code>from AlgoGraph import Graph, Vertex, Edge\n\n# Immutable graph\ng1 = Graph({Vertex('A', attrs={'value': 10})}, {Edge('A', 'B')})\n\n# Returns new graph\nv = g1.get_vertex('A')\nupdated_v = v.with_attrs(value=20)\ng2 = g1.update_vertex(updated_v)\n\n# Original unchanged\nprint(g1.get_vertex('A').get('value'))  # 10\nprint(g2.get_vertex('A').get('value'))  # 20\n\n# Thread-safe by default\n# No locks needed\n</code></pre>"},{"location":"design/immutability/#best-practices","title":"Best Practices","text":""},{"location":"design/immutability/#1-embrace-immutability","title":"1. Embrace Immutability","text":"<p>Don't fight it - work with it:</p> <pre><code># Don't try to \"modify\" in loops\n# BAD\ng = Graph()\nfor item in items:\n    g = g.add_vertex(Vertex(item))  # Many intermediate graphs\n\n# Good - build collections first\nvertices = {Vertex(item) for item in items}\ng = Graph(vertices)\n</code></pre>"},{"location":"design/immutability/#2-use-chaining","title":"2. Use Chaining","text":"<p>Chain operations for clarity:</p> <pre><code>result = (graph\n    .add_vertex(Vertex('A'))\n    .add_vertex(Vertex('B'))\n    .add_edge(Edge('A', 'B'))\n)\n</code></pre>"},{"location":"design/immutability/#3-keep-references-minimal","title":"3. Keep References Minimal","text":"<p>Don't keep unnecessary graph versions:</p> <pre><code># BAD - keeps all intermediate states\nstates = []\ng = Graph()\nfor i in range(1000):\n    g = g.add_vertex(Vertex(str(i)))\n    states.append(g)  # Lots of memory!\n\n# Good - keep only final state\ng = Graph({Vertex(str(i)) for i in range(1000)})\n</code></pre>"},{"location":"design/immutability/#4-leverage-structural-sharing","title":"4. Leverage Structural Sharing","text":"<p>Take advantage of shared structure:</p> <pre><code>base_graph = create_large_graph()  # Expensive\n\n# These are cheap - share most structure with base\nvariant1 = base_graph.add_vertex(Vertex('X'))\nvariant2 = base_graph.add_vertex(Vertex('Y'))\nvariant3 = base_graph.add_edge(Edge('A', 'B'))\n</code></pre>"},{"location":"design/immutability/#conclusion","title":"Conclusion","text":"<p>Immutability makes AlgoGraph:</p> <ul> <li>Safer: No unexpected modifications</li> <li>Simpler: Easier to reason about</li> <li>More Testable: Predictable behavior</li> <li>Thread-Safe: Use in concurrent code without locks</li> <li>Debuggable: Keep history of all states</li> </ul> <p>While there's a learning curve and some performance considerations, the benefits far outweigh the costs for most applications.</p>"},{"location":"design/immutability/#further-reading","title":"Further Reading","text":"<ul> <li>Core Concepts</li> <li>Composability</li> <li>Separation of Concerns</li> </ul>"},{"location":"examples/social-networks/","title":"Social Networks","text":"<p>Learn how to model and analyze social networks using AlgoGraph.</p>"},{"location":"examples/social-networks/#basic-social-network","title":"Basic Social Network","text":"<p>Let's create a simple friend network:</p> <pre><code>from AlgoGraph import Vertex, Edge, Graph\nfrom AlgoGraph.algorithms import (\n    shortest_path,\n    connected_components,\n    diameter,\n    find_bridges\n)\n\n# Create people with attributes\npeople = {\n    Vertex('Alice', attrs={\n        'age': 30,\n        'city': 'NYC',\n        'interests': ['reading', 'hiking'],\n        'join_date': '2020-01-15'\n    }),\n    Vertex('Bob', attrs={\n        'age': 25,\n        'city': 'Boston',\n        'interests': ['gaming', 'coding'],\n        'join_date': '2020-03-20'\n    }),\n    Vertex('Carol', attrs={\n        'age': 28,\n        'city': 'NYC',\n        'interests': ['hiking', 'photography'],\n        'join_date': '2020-02-10'\n    }),\n    Vertex('Dave', attrs={\n        'age': 35,\n        'city': 'Chicago',\n        'interests': ['reading', 'cooking'],\n        'join_date': '2019-11-05'\n    }),\n    Vertex('Eve', attrs={\n        'age': 32,\n        'city': 'Boston',\n        'interests': ['coding', 'music'],\n        'join_date': '2020-04-18'\n    }),\n}\n\n# Create friendships (undirected)\nfriendships = {\n    Edge('Alice', 'Bob', directed=False, attrs={'since': '2020-02-01'}),\n    Edge('Alice', 'Carol', directed=False, attrs={'since': '2020-02-15'}),\n    Edge('Bob', 'Eve', directed=False, attrs={'since': '2020-04-20'}),\n    Edge('Carol', 'Dave', directed=False, attrs={'since': '2020-03-10'}),\n    Edge('Dave', 'Eve', directed=False, attrs={'since': '2020-05-01'}),\n}\n\nnetwork = Graph(people, friendships)\n</code></pre>"},{"location":"examples/social-networks/#analysis-1-degrees-of-separation","title":"Analysis 1: Degrees of Separation","text":"<p>Find how connected people are:</p> <pre><code># Friend-of-a-friend analysis\ndef analyze_separation(network, person1, person2):\n    \"\"\"Analyze connection between two people.\"\"\"\n    path = shortest_path(network, person1, person2)\n\n    if not path:\n        return f\"{person1} and {person2} are not connected\"\n\n    separation = len(path) - 1\n\n    if separation == 0:\n        return f\"{person1} is {person2}\"\n    elif separation == 1:\n        return f\"{person1} and {person2} are direct friends\"\n    elif separation == 2:\n        middle = path[1]\n        return f\"{person1} and {person2} are friends-of-friends (through {middle})\"\n    else:\n        return f\"{person1} and {person2} are {separation} connections apart: {' -&gt; '.join(path)}\"\n\n# Test it\nprint(analyze_separation(network, 'Alice', 'Eve'))\n# Alice and Eve are friends-of-friends (through Bob)\n\nprint(analyze_separation(network, 'Alice', 'Dave'))\n# Alice and Dave are friends-of-friends (through Carol)\n</code></pre>"},{"location":"examples/social-networks/#analysis-2-find-influencers","title":"Analysis 2: Find Influencers","text":"<p>Identify well-connected people:</p> <pre><code>def find_influencers(network, min_friends=3):\n    \"\"\"Find people with many connections.\"\"\"\n    influencers = []\n\n    for person in network.vertices:\n        degree = network.degree(person.id)\n        if degree &gt;= min_friends:\n            influencers.append({\n                'name': person.id,\n                'friends': degree,\n                'city': person.get('city'),\n            })\n\n    # Sort by number of friends\n    return sorted(influencers, key=lambda x: x['friends'], reverse=True)\n\ninfluencers = find_influencers(network, min_friends=2)\nfor person in influencers:\n    print(f\"{person['name']}: {person['friends']} friends ({person['city']})\")\n</code></pre>"},{"location":"examples/social-networks/#analysis-3-community-detection","title":"Analysis 3: Community Detection","text":"<p>Find groups of closely connected people:</p> <pre><code># Find connected components\ncomponents = connected_components(network)\n\nprint(f\"Found {len(components)} community(ies):\")\nfor i, component in enumerate(components, 1):\n    members = sorted(component)\n    print(f\"\\nCommunity {i} ({len(members)} members):\")\n\n    # Show members and their details\n    for member in members:\n        person = network.get_vertex(member)\n        print(f\"  - {member} ({person.get('age')}, {person.get('city')})\")\n\n    # Find common interests\n    interests = set()\n    for member in members:\n        person = network.get_vertex(member)\n        interests.update(person.get('interests', []))\n\n    print(f\"  Common interests: {', '.join(sorted(interests))}\")\n</code></pre>"},{"location":"examples/social-networks/#analysis-4-critical-connections","title":"Analysis 4: Critical Connections","text":"<p>Find friendships that bridge communities:</p> <pre><code># Find bridge edges (removing them disconnects the network)\nbridges = find_bridges(network)\n\nif bridges:\n    print(\"Critical friendships (bridges):\")\n    for bridge in bridges:\n        edge = network.get_edge(bridge[0], bridge[1])\n        since = edge.get('since', 'unknown') if edge else 'unknown'\n        print(f\"  {bridge[0]} &lt;-&gt; {bridge[1]} (friends since {since})\")\nelse:\n    print(\"No critical friendships - network is well-connected\")\n</code></pre>"},{"location":"examples/social-networks/#analysis-5-friend-recommendations","title":"Analysis 5: Friend Recommendations","text":"<p>Suggest new friends based on mutual connections:</p> <pre><code>def recommend_friends(network, person_id, max_recommendations=3):\n    \"\"\"Recommend friends based on mutual connections.\"\"\"\n    if not network.has_vertex(person_id):\n        return []\n\n    # Get direct friends\n    direct_friends = network.neighbors(person_id)\n\n    # Get friends-of-friends\n    recommendations = {}\n    for friend in direct_friends:\n        friends_of_friend = network.neighbors(friend)\n        for potential_friend in friends_of_friend:\n            # Skip self and existing friends\n            if potential_friend == person_id or potential_friend in direct_friends:\n                continue\n\n            # Count mutual friends\n            if potential_friend not in recommendations:\n                recommendations[potential_friend] = {\n                    'mutual_friends': [],\n                    'score': 0\n                }\n\n            recommendations[potential_friend]['mutual_friends'].append(friend)\n            recommendations[potential_friend]['score'] += 1\n\n    # Sort by number of mutual friends\n    sorted_recs = sorted(\n        recommendations.items(),\n        key=lambda x: x[1]['score'],\n        reverse=True\n    )\n\n    # Format results\n    results = []\n    for person, data in sorted_recs[:max_recommendations]:\n        person_vertex = network.get_vertex(person)\n        results.append({\n            'name': person,\n            'mutual_friends': data['mutual_friends'],\n            'mutual_count': data['score'],\n            'age': person_vertex.get('age'),\n            'city': person_vertex.get('city'),\n            'interests': person_vertex.get('interests', [])\n        })\n\n    return results\n\n# Get recommendations for Alice\nrecommendations = recommend_friends(network, 'Alice', max_recommendations=3)\n\nprint(f\"\\nFriend recommendations for Alice:\")\nfor rec in recommendations:\n    mutuals = ', '.join(rec['mutual_friends'])\n    interests = ', '.join(rec['interests'])\n    print(f\"\\n{rec['name']} ({rec['age']}, {rec['city']})\")\n    print(f\"  {rec['mutual_count']} mutual friend(s): {mutuals}\")\n    print(f\"  Interests: {interests}\")\n</code></pre>"},{"location":"examples/social-networks/#analysis-6-shared-interests-network","title":"Analysis 6: Shared Interests Network","text":"<p>Create a bipartite graph of people and interests:</p> <pre><code>from AlgoGraph.algorithms import is_bipartite\n\n# Create interest vertices\nall_interests = set()\nfor person in network.vertices:\n    all_interests.update(person.get('interests', []))\n\ninterest_vertices = {\n    Vertex(interest, attrs={'type': 'interest'})\n    for interest in all_interests\n}\n\n# Create person-interest edges\nperson_interest_edges = set()\nfor person in network.vertices:\n    for interest in person.get('interests', []):\n        person_interest_edges.add(\n            Edge(person.id, interest, directed=False)\n        )\n\n# Create bipartite graph\npeople_vertices = {\n    v.with_attrs(type='person')\n    for v in network.vertices\n}\n\nbipartite_graph = Graph(\n    vertices=people_vertices | interest_vertices,\n    edges=person_interest_edges\n)\n\n# Verify it's bipartite\nis_bip, partition = is_bipartite(bipartite_graph)\nprint(f\"Is bipartite: {is_bip}\")\n\n# Find people who share interests\ndef find_shared_interests(person1_id, person2_id):\n    \"\"\"Find interests shared between two people.\"\"\"\n    interests1 = bipartite_graph.neighbors(person1_id)\n    interests2 = bipartite_graph.neighbors(person2_id)\n    return interests1 &amp; interests2\n\nshared = find_shared_interests('Alice', 'Dave')\nprint(f\"\\nAlice and Dave share interests: {shared}\")\n</code></pre>"},{"location":"examples/social-networks/#weighted-network-interaction-strength","title":"Weighted Network: Interaction Strength","text":"<p>Model relationship strength with edge weights:</p> <pre><code># Create network with interaction weights\nweighted_edges = {\n    Edge('Alice', 'Bob', directed=False, weight=0.9, attrs={\n        'messages': 150,\n        'last_interaction': '2025-10-25'\n    }),\n    Edge('Alice', 'Carol', directed=False, weight=0.8, attrs={\n        'messages': 120,\n        'last_interaction': '2025-10-24'\n    }),\n    Edge('Bob', 'Eve', directed=False, weight=0.7, attrs={\n        'messages': 90,\n        'last_interaction': '2025-10-23'\n    }),\n    # Low-weight connections (weak ties)\n    Edge('Carol', 'Dave', directed=False, weight=0.3, attrs={\n        'messages': 15,\n        'last_interaction': '2025-09-10'\n    }),\n}\n\nweighted_network = Graph(people, weighted_edges)\n\n# Find strong connections\ndef find_strong_connections(network, min_weight=0.7):\n    \"\"\"Find strong relationships.\"\"\"\n    strong = network.find_edges(lambda e: e.weight &gt;= min_weight)\n\n    results = []\n    for edge in strong:\n        results.append({\n            'connection': f\"{edge.source} &lt;-&gt; {edge.target}\",\n            'strength': edge.weight,\n            'messages': edge.get('messages', 0),\n            'last_contact': edge.get('last_interaction', 'unknown')\n        })\n\n    return sorted(results, key=lambda x: x['strength'], reverse=True)\n\nstrong_ties = find_strong_connections(weighted_network)\nprint(\"\\nStrong connections:\")\nfor tie in strong_ties:\n    print(f\"{tie['connection']}: strength {tie['strength']}\")\n    print(f\"  {tie['messages']} messages, last: {tie['last_contact']}\")\n</code></pre>"},{"location":"examples/social-networks/#network-metrics","title":"Network Metrics","text":"<p>Calculate important network statistics:</p> <pre><code>from AlgoGraph.algorithms import diameter\n\ndef network_statistics(network):\n    \"\"\"Calculate key network metrics.\"\"\"\n    stats = {\n        'total_people': network.vertex_count,\n        'total_friendships': network.edge_count,\n        'components': len(connected_components(network)),\n        'is_connected': len(connected_components(network)) == 1,\n    }\n\n    # Average degree\n    degrees = [network.degree(v.id) for v in network.vertices]\n    stats['avg_friends'] = sum(degrees) / len(degrees) if degrees else 0\n    stats['max_friends'] = max(degrees) if degrees else 0\n    stats['min_friends'] = min(degrees) if degrees else 0\n\n    # Diameter (if connected)\n    if stats['is_connected']:\n        stats['diameter'] = diameter(network)\n    else:\n        stats['diameter'] = None\n\n    return stats\n\nstats = network_statistics(network)\nprint(\"\\nNetwork Statistics:\")\nprint(f\"People: {stats['total_people']}\")\nprint(f\"Friendships: {stats['total_friendships']}\")\nprint(f\"Average friends: {stats['avg_friends']:.1f}\")\nprint(f\"Max friends: {stats['max_friends']}\")\nprint(f\"Network diameter: {stats['diameter']}\")\n</code></pre>"},{"location":"examples/social-networks/#saving-and-loading","title":"Saving and Loading","text":"<p>Persist your social network:</p> <pre><code>from AlgoGraph import save_graph, load_graph\n\n# Save network\nsave_graph(network, 'social_network.json')\n\n# Load it back\nloaded_network = load_graph('social_network.json')\n\n# Verify\nassert loaded_network.vertex_count == network.vertex_count\nassert loaded_network.edge_count == network.edge_count\n</code></pre>"},{"location":"examples/social-networks/#interactive-exploration","title":"Interactive Exploration","text":"<p>Use the shell to explore interactively:</p> <pre><code>$ python3 -m AlgoGraph.shell.shell social_network.json\n\ngraph(5v):/$ ls\nAlice/  [2 neighbors]\nBob/  [2 neighbors]\nCarol/  [2 neighbors]\nDave/  [2 neighbors]\nEve/  [2 neighbors]\n\ngraph(5v):/$ cd Alice\n\ngraph(5v):/Alice$ info\nVertex: Alice\nDegree: 2\n\nAttributes:\n  age = 30\n  city = NYC\n  interests = ['reading', 'hiking']\n\ngraph(5v):/Alice$ neighbors\nNeighbors of Alice:\n  Bob &lt;-&gt; (weight: 1.0)\n  Carol &lt;-&gt; (weight: 1.0)\n\ngraph(5v):/Alice$ path Alice Eve\nPath found: Alice -&gt; Bob -&gt; Eve\nLength: 2 edges\n</code></pre>"},{"location":"examples/social-networks/#next-steps","title":"Next Steps","text":"<ul> <li>See Road Networks for spatial graphs</li> <li>Check Dependency Graphs for DAG examples</li> <li>Explore more in Real-World Use Cases</li> </ul>"},{"location":"getting-started/examples/","title":"Basic Examples","text":"<p>This page provides practical examples to help you get started with AlgoGraph.</p>"},{"location":"getting-started/examples/#example-1-social-network-analysis","title":"Example 1: Social Network Analysis","text":"<p>A simple social network where we analyze friend connections:</p> <pre><code>from AlgoGraph import Vertex, Edge, Graph\nfrom AlgoGraph.algorithms import (\n    connected_components,\n    shortest_path,\n    shortest_path_length,\n    diameter\n)\n\n# Create people with attributes\npeople = {\n    Vertex('Alice', attrs={'age': 30, 'interests': ['reading', 'hiking']}),\n    Vertex('Bob', attrs={'age': 25, 'interests': ['gaming', 'coding']}),\n    Vertex('Carol', attrs={'age': 28, 'interests': ['hiking', 'photography']}),\n    Vertex('Dave', attrs={'age': 35, 'interests': ['reading', 'cooking']}),\n    Vertex('Eve', attrs={'age': 32, 'interests': ['coding', 'music']}),\n}\n\n# Create friendships (undirected, all weighted equally)\nfriendships = {\n    Edge('Alice', 'Bob', directed=False),\n    Edge('Alice', 'Carol', directed=False),\n    Edge('Bob', 'Eve', directed=False),\n    Edge('Carol', 'Dave', directed=False),\n    Edge('Dave', 'Eve', directed=False),\n}\n\nsocial_network = Graph(people, friendships)\n\n# Analysis 1: Find friend-of-friend connections\nprint(\"Alice's direct friends:\", social_network.neighbors('Alice'))\n# {'Bob', 'Carol'}\n\n# Analysis 2: Shortest path between people\npath = shortest_path(social_network, 'Alice', 'Eve')\nprint(f\"Shortest path from Alice to Eve: {' -&gt; '.join(path)}\")\n# Alice -&gt; Bob -&gt; Eve\n\n# Analysis 3: Find degree of separation\nseparation = shortest_path_length(social_network, 'Alice', 'Dave')\nprint(f\"Alice and Dave are {separation} connections apart\")\n# 2\n\n# Analysis 4: Check network connectivity\ncomponents = connected_components(social_network)\nprint(f\"Network has {len(components)} connected component(s)\")\n# 1 (everyone is connected)\n\n# Analysis 5: Find the network diameter (longest shortest path)\nnetwork_diameter = diameter(social_network)\nprint(f\"Network diameter: {network_diameter}\")\n# Maximum separation in the network\n\n# Find people with shared interests\ndef find_people_by_interest(graph, interest):\n    return {\n        v.id for v in graph.find_vertices(\n            lambda v: interest in v.get('interests', [])\n        )\n    }\n\nhikers = find_people_by_interest(social_network, 'hiking')\nprint(f\"People interested in hiking: {hikers}\")\n# {'Alice', 'Carol'}\n</code></pre>"},{"location":"getting-started/examples/#example-2-task-dependency-graph","title":"Example 2: Task Dependency Graph","text":"<p>Model project tasks with dependencies:</p> <pre><code>from AlgoGraph import Vertex, Edge, Graph\nfrom AlgoGraph.algorithms import (\n    topological_sort,\n    has_cycle,\n    find_path\n)\n\n# Define tasks with estimated hours\ntasks = {\n    Vertex('design', attrs={'hours': 8, 'assignee': 'Alice'}),\n    Vertex('setup_env', attrs={'hours': 2, 'assignee': 'Bob'}),\n    Vertex('backend', attrs={'hours': 16, 'assignee': 'Carol'}),\n    Vertex('frontend', attrs={'hours': 12, 'assignee': 'Dave'}),\n    Vertex('testing', attrs={'hours': 8, 'assignee': 'Eve'}),\n    Vertex('deployment', attrs={'hours': 4, 'assignee': 'Bob'}),\n}\n\n# Define dependencies (A -&gt; B means B depends on A)\ndependencies = {\n    Edge('design', 'backend'),\n    Edge('design', 'frontend'),\n    Edge('setup_env', 'backend'),\n    Edge('setup_env', 'frontend'),\n    Edge('backend', 'testing'),\n    Edge('frontend', 'testing'),\n    Edge('testing', 'deployment'),\n}\n\nproject = Graph(tasks, dependencies)\n\n# Check for circular dependencies\nif has_cycle(project):\n    print(\"ERROR: Circular dependency detected!\")\nelse:\n    print(\"No circular dependencies found\")\n\n# Get execution order\nexecution_order = topological_sort(project)\nprint(\"\\nTask execution order:\")\nfor i, task_id in enumerate(execution_order, 1):\n    task = project.get_vertex(task_id)\n    print(f\"{i}. {task_id} ({task.get('hours')}h, {task.get('assignee')})\")\n\n# Find critical path to deployment\ncritical_path = find_path(project, 'design', 'deployment')\ntotal_hours = sum(\n    project.get_vertex(task).get('hours')\n    for task in critical_path\n)\nprint(f\"\\nCritical path: {' -&gt; '.join(critical_path)}\")\nprint(f\"Minimum project duration: {total_hours} hours\")\n\n# Find which tasks can run in parallel\ndef find_parallel_tasks(graph, order):\n    \"\"\"Group tasks that can run simultaneously.\"\"\"\n    levels = []\n    completed = set()\n\n    for task in order:\n        # Check if all dependencies are completed\n        deps = {e.source for e in graph.edges if e.target == task}\n        if deps.issubset(completed):\n            # Can start immediately\n            if not levels or task in completed:\n                levels.append([task])\n            else:\n                levels[-1].append(task)\n        else:\n            # Must wait for dependencies\n            levels.append([task])\n        completed.add(task)\n\n    return levels\n\nparallel_groups = find_parallel_tasks(project, execution_order)\nprint(\"\\nParallel execution phases:\")\nfor i, phase in enumerate(parallel_groups, 1):\n    print(f\"Phase {i}: {', '.join(phase)}\")\n</code></pre>"},{"location":"getting-started/examples/#example-3-city-road-network","title":"Example 3: City Road Network","text":"<p>Shortest path in a weighted graph:</p> <pre><code>from AlgoGraph import Vertex, Edge, Graph\nfrom AlgoGraph.algorithms import (\n    dijkstra,\n    shortest_path,\n    all_shortest_paths\n)\n\n# Cities with population data\ncities = {\n    Vertex('Boston', attrs={'population': 675000}),\n    Vertex('NYC', attrs={'population': 8336000}),\n    Vertex('Philadelphia', attrs={'population': 1584000}),\n    Vertex('Washington DC', attrs={'population': 705000}),\n    Vertex('Baltimore', attrs={'population': 585000}),\n}\n\n# Roads with distances in miles\nroads = {\n    Edge('Boston', 'NYC', weight=215),\n    Edge('NYC', 'Philadelphia', weight=95),\n    Edge('Philadelphia', 'Baltimore', weight=100),\n    Edge('Baltimore', 'Washington DC', weight=40),\n    Edge('Philadelphia', 'Washington DC', weight=140),\n    Edge('NYC', 'Baltimore', weight=185),\n}\n\nroad_network = Graph(cities, roads)\n\n# Find shortest routes from Boston\ndistances, predecessors = dijkstra(road_network, 'Boston')\n\nprint(\"Distances from Boston:\")\nfor city in sorted(distances.keys()):\n    if city != 'Boston':\n        print(f\"  {city}: {distances[city]} miles\")\n\n# Get the actual shortest path\npath_to_dc = shortest_path(road_network, 'Boston', 'Washington DC')\nprint(f\"\\nShortest route to Washington DC:\")\nprint(' -&gt; '.join(path_to_dc))\nprint(f\"Total distance: {distances['Washington DC']} miles\")\n\n# Find all shortest paths (if multiple exist)\nall_paths = all_shortest_paths(road_network, 'NYC', 'Washington DC')\nprint(f\"\\nAll shortest paths from NYC to Washington DC:\")\nfor path in all_paths:\n    print(f\"  {' -&gt; '.join(path)}\")\n\n# Find cities within a certain distance\ndef cities_within_distance(graph, start, max_distance):\n    \"\"\"Find all cities within max_distance from start.\"\"\"\n    distances, _ = dijkstra(graph, start)\n    return {\n        city: dist\n        for city, dist in distances.items()\n        if dist &lt;= max_distance and city != start\n    }\n\nnearby = cities_within_distance(road_network, 'Boston', 300)\nprint(f\"\\nCities within 300 miles of Boston:\")\nfor city, dist in sorted(nearby.items(), key=lambda x: x[1]):\n    print(f\"  {city}: {dist} miles\")\n</code></pre>"},{"location":"getting-started/examples/#example-4-bipartite-matching","title":"Example 4: Bipartite Matching","text":"<p>Model a bipartite graph (e.g., students and courses):</p> <pre><code>from AlgoGraph import Vertex, Edge, Graph\nfrom AlgoGraph.algorithms import is_bipartite\n\n# Create students and courses\nstudents = {\n    Vertex('Alice', attrs={'type': 'student', 'year': 3}),\n    Vertex('Bob', attrs={'type': 'student', 'year': 2}),\n    Vertex('Carol', attrs={'type': 'student', 'year': 4}),\n}\n\ncourses = {\n    Vertex('CS101', attrs={'type': 'course', 'capacity': 30}),\n    Vertex('CS201', attrs={'type': 'course', 'capacity': 25}),\n    Vertex('CS301', attrs={'type': 'course', 'capacity': 20}),\n}\n\n# Create enrollments (undirected edges)\nenrollments = {\n    Edge('Alice', 'CS101', directed=False),\n    Edge('Alice', 'CS201', directed=False),\n    Edge('Bob', 'CS101', directed=False),\n    Edge('Bob', 'CS301', directed=False),\n    Edge('Carol', 'CS201', directed=False),\n    Edge('Carol', 'CS301', directed=False),\n}\n\nenrollment_graph = Graph(students | courses, enrollments)\n\n# Verify it's bipartite (students never connect to students,\n# courses never connect to courses)\nbipartite, partition = is_bipartite(enrollment_graph)\nprint(f\"Is bipartite: {bipartite}\")\n\nif bipartite:\n    set1, set2 = partition\n    print(f\"Partition 1: {set1}\")\n    print(f\"Partition 2: {set2}\")\n\n# Find students in a specific course\ndef students_in_course(graph, course_id):\n    return graph.neighbors(course_id)\n\nprint(f\"\\nStudents in CS101: {students_in_course(enrollment_graph, 'CS101')}\")\n\n# Find courses for a student\ndef courses_for_student(graph, student_id):\n    return graph.neighbors(student_id)\n\nprint(f\"Alice's courses: {courses_for_student(enrollment_graph, 'Alice')}\")\n\n# Find students enrolled in multiple courses\ndef students_with_multiple_courses(graph, min_courses):\n    student_vertices = graph.find_vertices(\n        lambda v: v.get('type') == 'student'\n    )\n    return {\n        v.id for v in student_vertices\n        if graph.degree(v.id) &gt;= min_courses\n    }\n\noverloaded = students_with_multiple_courses(enrollment_graph, 2)\nprint(f\"\\nStudents taking 2+ courses: {overloaded}\")\n</code></pre>"},{"location":"getting-started/examples/#example-5-graph-transformation","title":"Example 5: Graph Transformation","text":"<p>Modify graphs immutably:</p> <pre><code>from AlgoGraph import Vertex, Edge, Graph\n\n# Start with a simple graph\noriginal = Graph(\n    vertices={Vertex('A'), Vertex('B'), Vertex('C')},\n    edges={Edge('A', 'B'), Edge('B', 'C')}\n)\n\n# Add vertex attributes\ndef add_labels(graph):\n    \"\"\"Add labels to all vertices.\"\"\"\n    new_graph = graph\n    for v in graph.vertices:\n        updated = v.with_attrs(label=f\"Vertex {v.id}\")\n        new_graph = new_graph.update_vertex(updated)\n    return new_graph\n\nlabeled = add_labels(original)\n\n# Convert directed to undirected\ndef to_undirected(graph):\n    \"\"\"Convert all edges to undirected.\"\"\"\n    new_edges = {e.to_undirected() for e in graph.edges}\n    return Graph(vertices=graph.vertices, edges=new_edges)\n\nundirected = to_undirected(original)\n\n# Scale all edge weights\ndef scale_weights(graph, factor):\n    \"\"\"Multiply all edge weights by a factor.\"\"\"\n    new_edges = {e.with_weight(e.weight * factor) for e in graph.edges}\n    return Graph(vertices=graph.vertices, edges=new_edges)\n\nweighted = Graph(\n    vertices={Vertex('A'), Vertex('B')},\n    edges={Edge('A', 'B', weight=10)}\n)\nscaled = scale_weights(weighted, 2.5)\nprint(scaled.get_edge('A', 'B').weight)  # 25.0\n\n# Filter graph by predicate\ndef filter_by_degree(graph, min_degree):\n    \"\"\"Keep only vertices with degree &gt;= min_degree.\"\"\"\n    valid_vertices = {\n        v.id for v in graph.vertices\n        if graph.degree(v.id) &gt;= min_degree\n    }\n    return graph.subgraph(valid_vertices)\n\nfiltered = filter_by_degree(original, 2)\nprint(f\"Vertices with degree &gt;= 2: {[v.id for v in filtered.vertices]}\")\n</code></pre>"},{"location":"getting-started/examples/#next-steps","title":"Next Steps","text":"<p>These examples demonstrate common patterns in AlgoGraph. For more advanced use cases:</p> <ul> <li>Browse the Cookbook for real-world scenarios</li> <li>Learn about all Available Algorithms</li> <li>Explore the API Reference for detailed documentation</li> <li>Try the Interactive Shell to explore graphs hands-on</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install and configure AlgoGraph on your system.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>(Optional) AlgoTree library for tree-graph interoperability</li> </ul>"},{"location":"getting-started/installation/#installation-steps","title":"Installation Steps","text":""},{"location":"getting-started/installation/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<p>Currently, AlgoGraph is available from the source repository:</p> <pre><code>git clone https://github.com/released/AlgoGraph.git\ncd AlgoGraph\n</code></pre>"},{"location":"getting-started/installation/#step-2-set-up-pythonpath","title":"Step 2: Set Up PYTHONPATH","text":"<p>AlgoGraph requires you to configure your <code>PYTHONPATH</code> to include the parent directory of the repository.</p>"},{"location":"getting-started/installation/#on-linuxmacos","title":"On Linux/macOS","text":"<p>Add the following to your <code>~/.bashrc</code> or <code>~/.zshrc</code>:</p> <pre><code>export PYTHONPATH=/path/to/released:$PYTHONPATH\n</code></pre> <p>For example, if you cloned the repository to <code>/home/user/github/released/AlgoGraph</code>:</p> <pre><code>export PYTHONPATH=/home/user/github/released:$PYTHONPATH\n</code></pre> <p>Then reload your shell configuration:</p> <pre><code>source ~/.bashrc  # or source ~/.zshrc\n</code></pre>"},{"location":"getting-started/installation/#on-windows","title":"On Windows","text":"<p>Using Command Prompt:</p> <pre><code>set PYTHONPATH=C:\\path\\to\\released;%PYTHONPATH%\n</code></pre> <p>Using PowerShell:</p> <pre><code>$env:PYTHONPATH = \"C:\\path\\to\\released;$env:PYTHONPATH\"\n</code></pre> <p>Permanent Configuration:</p> <ol> <li>Right-click on \"This PC\" or \"My Computer\"</li> <li>Select \"Properties\" \u2192 \"Advanced system settings\"</li> <li>Click \"Environment Variables\"</li> <li>Under \"User variables\", click \"New\"</li> <li>Variable name: <code>PYTHONPATH</code></li> <li>Variable value: <code>C:\\path\\to\\released</code></li> </ol>"},{"location":"getting-started/installation/#step-3-verify-installation","title":"Step 3: Verify Installation","text":"<p>Test that AlgoGraph is correctly installed:</p> <pre><code>python3 -c \"from AlgoGraph import Vertex, Edge, Graph; print('AlgoGraph installed successfully!')\"\n</code></pre> <p>You should see: <pre><code>AlgoGraph installed successfully!\n</code></pre></p>"},{"location":"getting-started/installation/#optional-install-algotree","title":"Optional: Install AlgoTree","text":"<p>For tree-graph interoperability features, install AlgoTree:</p> <pre><code># Clone AlgoTree (if in same parent directory)\ncd /path/to/released\ngit clone https://github.com/released/AlgoTree.git\n</code></pre> <p>Update your <code>PYTHONPATH</code> as described above to include both libraries.</p> <p>Verify AlgoTree integration:</p> <pre><code>python3 -c \"from AlgoGraph.interop import tree_to_graph; print('AlgoTree integration available!')\"\n</code></pre> <p>AlgoTree is Optional</p> <p>AlgoTree integration is completely optional. All core AlgoGraph features work without it. You only need AlgoTree if you want to convert between tree and graph representations.</p>"},{"location":"getting-started/installation/#interactive-shell","title":"Interactive Shell","text":"<p>To use the interactive graph shell:</p> <pre><code>cd /path/to/released/AlgoGraph\npython3 -m AlgoGraph.shell.shell\n</code></pre> <p>Or load a specific graph file:</p> <pre><code>python3 -m AlgoGraph.shell.shell path/to/graph.json\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you plan to contribute to AlgoGraph or run tests:</p> <pre><code># Install development dependencies\npip install pytest pytest-benchmark\n\n# Run tests\ncd /path/to/released/AlgoGraph\npytest\n\n# Run with coverage\npytest --cov=AlgoGraph\n\n# Run benchmarks\npytest test/ --benchmark-only\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#import-error-no-module-named-algograph","title":"Import Error: No module named 'AlgoGraph'","text":"<p>Problem: Python cannot find the AlgoGraph module.</p> <p>Solution: Verify your <code>PYTHONPATH</code> is set correctly:</p> <pre><code>echo $PYTHONPATH  # Linux/macOS\necho %PYTHONPATH%  # Windows CMD\n$env:PYTHONPATH    # Windows PowerShell\n</code></pre> <p>Make sure it includes the parent directory of AlgoGraph (the <code>released</code> directory, not <code>AlgoGraph</code> itself).</p>"},{"location":"getting-started/installation/#import-error-no-module-named-algotree","title":"Import Error: No module named 'AlgoTree'","text":"<p>Problem: AlgoTree features are being used but AlgoTree is not installed.</p> <p>Solution: Either install AlgoTree (see above) or avoid using interop functions like <code>tree_to_graph</code> and <code>graph_to_tree</code>.</p>"},{"location":"getting-started/installation/#shell-commands-dont-have-tab-completion","title":"Shell Commands Don't Have Tab Completion","text":"<p>Problem: Tab completion doesn't work in the interactive shell.</p> <p>Solution: Install readline support:</p> <pre><code># Linux/macOS (usually included)\npip install readline\n\n# Windows\npip install pyreadline3\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have AlgoGraph installed, proceed to:</p> <ul> <li>Quick Start Guide - Learn the basics</li> <li>Basic Examples - See common use cases</li> <li>Core Concepts - Understand the fundamentals</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will get you up and running with AlgoGraph in just a few minutes.</p>"},{"location":"getting-started/quickstart/#your-first-graph","title":"Your First Graph","text":"<p>Let's create a simple social network graph:</p> <pre><code>from AlgoGraph import Vertex, Edge, Graph\n\n# Create vertices representing people\nalice = Vertex('Alice', attrs={'age': 30, 'city': 'NYC'})\nbob = Vertex('Bob', attrs={'age': 25, 'city': 'Boston'})\ncharlie = Vertex('Charlie', attrs={'age': 35, 'city': 'NYC'})\n\n# Create edges representing friendships (undirected)\nfriendship1 = Edge('Alice', 'Bob', directed=False)\nfriendship2 = Edge('Bob', 'Charlie', directed=False)\n\n# Build the graph\ngraph = Graph(\n    vertices={alice, bob, charlie},\n    edges={friendship1, friendship2}\n)\n\nprint(graph)  # Graph with 3 vertices and 2 edges\n</code></pre>"},{"location":"getting-started/quickstart/#basic-graph-operations","title":"Basic Graph Operations","text":""},{"location":"getting-started/quickstart/#checking-vertex-and-edge-existence","title":"Checking Vertex and Edge Existence","text":"<pre><code># Check if a vertex exists\nprint(graph.has_vertex('Alice'))  # True\nprint(graph.has_vertex('Diana'))  # False\n\n# Check if an edge exists\nprint(graph.has_edge('Alice', 'Bob'))  # True\nprint(graph.has_edge('Alice', 'Charlie'))  # False\n</code></pre>"},{"location":"getting-started/quickstart/#getting-vertex-information","title":"Getting Vertex Information","text":"<pre><code># Get a specific vertex\nalice = graph.get_vertex('Alice')\nprint(alice.id)  # 'Alice'\nprint(alice.get('age'))  # 30\nprint(alice.get('city'))  # 'NYC'\n\n# Get all neighbors of a vertex\nneighbors = graph.neighbors('Bob')\nprint(neighbors)  # {'Alice', 'Charlie'}\n\n# Get vertex degree\nprint(graph.degree('Bob'))  # 2\n</code></pre>"},{"location":"getting-started/quickstart/#modifying-graphs-immutably","title":"Modifying Graphs (Immutably)","text":"<p>AlgoGraph uses immutable data structures. When you \"modify\" a graph, you get a new graph back:</p> <pre><code># Add a new vertex\ndiana = Vertex('Diana', attrs={'age': 28, 'city': 'Seattle'})\ngraph2 = graph.add_vertex(diana)\n\nprint(graph.vertex_count)   # 3 (original unchanged)\nprint(graph2.vertex_count)  # 4 (new graph)\n\n# Add a new edge\nedge = Edge('Charlie', 'Diana', directed=False)\ngraph3 = graph2.add_edge(edge)\n\n# Chain operations\ngraph4 = (graph\n    .add_vertex(Vertex('Eve'))\n    .add_edge(Edge('Diana', 'Eve', directed=False))\n)\n</code></pre>"},{"location":"getting-started/quickstart/#running-algorithms","title":"Running Algorithms","text":"<p>AlgoGraph provides 30+ graph algorithms in separate modules:</p>"},{"location":"getting-started/quickstart/#path-finding","title":"Path Finding","text":"<pre><code>from AlgoGraph.algorithms import find_path, shortest_path\n\n# Find any path between two vertices\npath = find_path(graph, 'Alice', 'Charlie')\nprint(path)  # ['Alice', 'Bob', 'Charlie']\n\n# Find shortest path (considers edge weights)\nshortest = shortest_path(graph, 'Alice', 'Charlie')\nprint(shortest)  # ['Alice', 'Bob', 'Charlie']\n</code></pre>"},{"location":"getting-started/quickstart/#breadth-first-search","title":"Breadth-First Search","text":"<pre><code>from AlgoGraph.algorithms import bfs\n\n# Perform BFS from a starting vertex\norder = bfs(graph, 'Alice')\nprint(order)  # ['Alice', 'Bob', 'Charlie'] (visit order)\n</code></pre>"},{"location":"getting-started/quickstart/#connected-components","title":"Connected Components","text":"<pre><code>from AlgoGraph.algorithms import connected_components, is_connected\n\n# Find all connected components\ncomponents = connected_components(graph)\nprint(components)  # [{'Alice', 'Bob', 'Charlie'}]\n\n# Check if graph is connected\nprint(is_connected(graph))  # True\n</code></pre>"},{"location":"getting-started/quickstart/#working-with-weighted-graphs","title":"Working with Weighted Graphs","text":"<p>Create a road network with distances:</p> <pre><code># Create a weighted directed graph\ncities = {\n    Vertex('Boston'),\n    Vertex('NYC'),\n    Vertex('Philadelphia'),\n    Vertex('Washington DC')\n}\n\nroads = {\n    Edge('Boston', 'NYC', weight=215),      # miles\n    Edge('NYC', 'Philadelphia', weight=95),\n    Edge('Philadelphia', 'Washington DC', weight=140),\n    Edge('Boston', 'Philadelphia', weight=310),\n}\n\nroad_network = Graph(cities, roads)\n\n# Find shortest path using Dijkstra's algorithm\nfrom AlgoGraph.algorithms import dijkstra\n\ndistances, predecessors = dijkstra(road_network, 'Boston')\n\nprint(f\"Boston to NYC: {distances['NYC']} miles\")\nprint(f\"Boston to Washington DC: {distances['Washington DC']} miles\")\n</code></pre>"},{"location":"getting-started/quickstart/#saving-and-loading-graphs","title":"Saving and Loading Graphs","text":"<pre><code>from AlgoGraph import save_graph, load_graph\n\n# Save to JSON\nsave_graph(graph, 'my_social_network.json')\n\n# Load from JSON\nloaded_graph = load_graph('my_social_network.json')\n\nprint(loaded_graph.vertex_count)  # Same as original\n</code></pre>"},{"location":"getting-started/quickstart/#interactive-exploration","title":"Interactive Exploration","text":"<p>Launch the interactive shell to explore graphs:</p> <pre><code>python3 -m AlgoGraph.shell.shell my_social_network.json\n</code></pre> <p>In the shell, you can navigate the graph like a file system:</p> <pre><code>graph(3v):/$ ls\nAlice/  [2 neighbors]\nBob/  [2 neighbors]\nCharlie/  [1 neighbors]\n\ngraph(3v):/$ cd Alice\n\ngraph(3v):/Alice$ ls\nAttributes:\n  age = 30\n  city = NYC\n\nneighbors/  [2 vertices]\n\ngraph(3v):/Alice$ cd neighbors\n\ngraph(3v):/Alice/neighbors$ ls\nBob/  &lt;-&gt; [weight: 1.0]\nCharlie/  &lt;-&gt; [weight: 1.0]\n\ngraph(3v):/Alice/neighbors$ cd Bob\n\ngraph(3v):/Bob$ info\nVertex: Bob\nDegree: 2\n\nAttributes:\n  age = 25\n  city = Boston\n</code></pre>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#creating-graphs-from-data","title":"Creating Graphs from Data","text":"<pre><code># From a list of edges\nedge_list = [\n    ('A', 'B', 5),   # (source, target, weight)\n    ('B', 'C', 3),\n    ('C', 'D', 7),\n]\n\nvertices = {Vertex(v) for edge in edge_list for v in edge[:2]}\nedges = {Edge(src, tgt, weight=w) for src, tgt, w in edge_list}\ngraph = Graph(vertices, edges)\n\n# From an adjacency dictionary\nadj_dict = {\n    'A': ['B', 'C'],\n    'B': ['C', 'D'],\n    'C': ['D'],\n    'D': []\n}\n\nvertices = {Vertex(v) for v in adj_dict.keys()}\nedges = {\n    Edge(src, tgt)\n    for src, targets in adj_dict.items()\n    for tgt in targets\n}\ngraph = Graph(vertices, edges)\n</code></pre>"},{"location":"getting-started/quickstart/#filtering-vertices-and-edges","title":"Filtering Vertices and Edges","text":"<pre><code># Find vertices with specific attributes\nnyc_residents = graph.find_vertices(\n    lambda v: v.get('city') == 'NYC'\n)\n\n# Find edges with weight &gt; threshold\nheavy_edges = graph.find_edges(\n    lambda e: e.weight &gt; 100\n)\n\n# Create subgraph\nsubgraph = graph.subgraph({'Alice', 'Bob'})\n</code></pre>"},{"location":"getting-started/quickstart/#updating-attributes","title":"Updating Attributes","text":"<pre><code># Update a vertex's attributes (returns new graph)\nalice = graph.get_vertex('Alice')\nupdated_alice = alice.with_attrs(age=31, job='Engineer')\ngraph2 = graph.update_vertex(updated_alice)\n\n# Update an edge's weight\nedge = graph.get_edge('Alice', 'Bob')\nupdated_edge = edge.with_weight(2.5)\ngraph3 = graph.update_edge(updated_edge)\n</code></pre>"},{"location":"getting-started/quickstart/#whats-next","title":"What's Next?","text":"<p>Now that you understand the basics, you can:</p> <ul> <li>Learn about Core Concepts in depth</li> <li>Explore all available Graph Algorithms</li> <li>See more Examples</li> <li>Browse the API Reference</li> <li>Try the Interactive Shell</li> </ul>"},{"location":"shell/overview/","title":"Interactive Shell Overview","text":"<p>The AlgoGraph interactive shell provides a VFS-like interface for exploring graphs. Navigate through graphs as if they were a file system, run queries, and visualize graph structure interactively.</p>"},{"location":"shell/overview/#starting-the-shell","title":"Starting the Shell","text":""},{"location":"shell/overview/#with-a-graph-file","title":"With a Graph File","text":"<pre><code>python3 -m AlgoGraph.shell.shell path/to/graph.json\n</code></pre>"},{"location":"shell/overview/#with-sample-data","title":"With Sample Data","text":"<pre><code>python3 -m AlgoGraph.shell.shell\n</code></pre> <p>This loads a sample social network for exploration.</p>"},{"location":"shell/overview/#programmatically","title":"Programmatically","text":"<pre><code>from AlgoGraph import Graph, Vertex, Edge\nfrom AlgoGraph.shell import GraphShell, GraphContext\n\n# Create your graph\ngraph = Graph(\n    vertices={Vertex('A'), Vertex('B'), Vertex('C')},\n    edges={Edge('A', 'B'), Edge('B', 'C')}\n)\n\n# Start shell\ncontext = GraphContext(graph)\nshell = GraphShell(context)\nshell.run()\n</code></pre>"},{"location":"shell/overview/#shell-basics","title":"Shell Basics","text":""},{"location":"shell/overview/#the-prompt","title":"The Prompt","text":"<p>The shell prompt shows the current location and graph size:</p> <pre><code>graph(5v):/$\n</code></pre> <ul> <li><code>graph</code>: You're in a graph shell</li> <li><code>(5v)</code>: Graph has 5 vertices</li> <li><code>/</code>: Current location (root in this case)</li> <li><code>$</code>: Prompt character</li> </ul>"},{"location":"shell/overview/#navigation-hierarchy","title":"Navigation Hierarchy","text":"<p>The shell has three levels:</p> <ol> <li>Root (<code>/</code>): View all vertices</li> <li>Vertex (<code>/Alice</code>): View a specific vertex and its attributes</li> <li>Neighbors (<code>/Alice/neighbors</code>): View a vertex's neighbors</li> </ol> <pre><code>/                    # Root - all vertices\n\u251c\u2500\u2500 Alice/           # Vertex level\n\u2502   \u2514\u2500\u2500 neighbors/   # Neighbors of Alice\n\u251c\u2500\u2500 Bob/\n\u2502   \u2514\u2500\u2500 neighbors/\n\u2514\u2500\u2500 Charlie/\n    \u2514\u2500\u2500 neighbors/\n</code></pre>"},{"location":"shell/overview/#basic-commands","title":"Basic Commands","text":""},{"location":"shell/overview/#pwd-print-working-directory","title":"pwd - Print Working Directory","text":"<p>Shows your current location:</p> <pre><code>graph(5v):/$ pwd\n/\n\ngraph(5v):/Alice$ pwd\n/Alice\n</code></pre>"},{"location":"shell/overview/#ls-list-contents","title":"ls - List Contents","text":"<p>List what's at the current location:</p> <pre><code># At root - shows all vertices\ngraph(5v):/$ ls\nAlice/  [2 neighbors]\nBob/  [3 neighbors]\nCharlie/  [1 neighbors]\n\n# At vertex - shows attributes and neighbors/\ngraph(5v):/Alice$ ls\nAttributes:\n  age = 30\n  city = NYC\n\nneighbors/  [2 vertices]\n\n# In neighbors mode - shows neighbors\ngraph(5v):/Alice/neighbors$ ls\nBob/  &lt;-&gt; [weight: 1.0]\nCharlie/  &lt;-&gt; [weight: 1.0]\n</code></pre>"},{"location":"shell/overview/#cd-change-directory","title":"cd - Change Directory","text":"<p>Navigate to different locations:</p> <pre><code># Go to a vertex\ngraph(5v):/$ cd Alice\nNow at: /Alice\n\n# Enter neighbors mode\ngraph(5v):/Alice$ cd neighbors\nNow at: /Alice/neighbors\n\n# Navigate to a neighbor\ngraph(5v):/Alice/neighbors$ cd Bob\nNow at: /Bob\n\n# Go up one level\ngraph(5v):/Bob$ cd ..\nNow at: /\n\n# Go to root\ngraph(5v):/Alice/neighbors$ cd /\nNow at: /\n\n# Use absolute paths\ngraph(5v):/$ cd /Alice\nNow at: /Alice\n</code></pre>"},{"location":"shell/overview/#information-commands","title":"Information Commands","text":""},{"location":"shell/overview/#info-show-information","title":"info - Show Information","text":"<p>Display details about current location:</p> <pre><code># At root - shows graph statistics\ngraph(5v):/$ info\nGraph Information:\n  Vertices: 5\n  Edges: 7\n  Type: Undirected\n\n# At vertex - shows vertex details\ngraph(5v):/Alice$ info\nVertex: Alice\nDegree: 2\n\nAttributes:\n  age = 30\n  city = NYC\n</code></pre>"},{"location":"shell/overview/#neighbors-show-neighbors","title":"neighbors - Show Neighbors","text":"<p>Quick view of a vertex's neighbors (alternative to <code>cd neighbors</code> + <code>ls</code>):</p> <pre><code>graph(5v):/Alice$ neighbors\nNeighbors of Alice:\n  Bob &lt;-&gt; (weight: 1.0)\n  Charlie &lt;-&gt; (weight: 1.0)\n</code></pre>"},{"location":"shell/overview/#find-find-a-vertex","title":"find - Find a Vertex","text":"<p>Search for a vertex anywhere in the graph:</p> <pre><code>graph(5v):/$ find Charlie\nFound: Charlie\nDegree: 1\nAttributes:\n  age = 35\n  city = NYC\n</code></pre>"},{"location":"shell/overview/#query-commands","title":"Query Commands","text":""},{"location":"shell/overview/#path-find-any-path","title":"path - Find Any Path","text":"<p>Find a path between two vertices:</p> <pre><code>graph(5v):/$ path Alice Diana\nPath found: Alice -&gt; Bob -&gt; Diana\nLength: 2 edges\n</code></pre>"},{"location":"shell/overview/#shortest-find-shortest-path","title":"shortest - Find Shortest Path","text":"<p>Find the shortest weighted path:</p> <pre><code>graph(5v):/$ shortest Alice Diana\nShortest path: Alice -&gt; Bob -&gt; Diana\nDistance: 2.0\n</code></pre>"},{"location":"shell/overview/#components-show-connected-components","title":"components - Show Connected Components","text":"<p>Analyze graph connectivity:</p> <pre><code>graph(5v):/$ components\nConnected components: 1\n\nComponent 1 (5 vertices):\n  Alice, Bob, Charlie, Diana, Eve\n</code></pre>"},{"location":"shell/overview/#bfs-breadth-first-search","title":"bfs - Breadth-First Search","text":"<p>Run BFS from a vertex:</p> <pre><code>graph(5v):/Alice$ bfs\nBFS from Alice:\nAlice -&gt; Bob -&gt; Charlie -&gt; Diana -&gt; Eve\n\nVisited 5 vertices\n\n# Or specify starting vertex\ngraph(5v):/$ bfs Bob\nBFS from Bob:\nBob -&gt; Alice -&gt; Charlie -&gt; Diana -&gt; Eve\n\nVisited 5 vertices\n</code></pre>"},{"location":"shell/overview/#file-operations","title":"File Operations","text":""},{"location":"shell/overview/#save-save-graph","title":"save - Save Graph","text":"<p>Save the current graph to a JSON file:</p> <pre><code>graph(5v):/$ save my_graph.json\nGraph saved to my_graph.json\n</code></pre>"},{"location":"shell/overview/#shell-features","title":"Shell Features","text":""},{"location":"shell/overview/#tab-completion","title":"Tab Completion","text":"<p>Press TAB to autocomplete:</p> <pre><code>graph(5v):/$ cd Al&lt;TAB&gt;\ngraph(5v):/$ cd Alice\n</code></pre> <p>Works for: - Command names - Vertex names - Special keywords (<code>neighbors</code>, <code>..</code>, <code>/</code>)</p>"},{"location":"shell/overview/#command-history","title":"Command History","text":"<p>Use UP/DOWN arrow keys to navigate command history:</p> <pre><code># Press UP to recall previous commands\n# Press DOWN to go forward in history\n</code></pre>"},{"location":"shell/overview/#quoted-names","title":"Quoted Names","text":"<p>Use quotes for vertex names with spaces or special characters:</p> <pre><code>graph(5v):/$ cd \"Alice Smith\"\nNow at: /Alice Smith\n\ngraph(5v):/Alice Smith$ cd ..\nNow at: /\n</code></pre>"},{"location":"shell/overview/#absolute-vs-relative-paths","title":"Absolute vs. Relative Paths","text":"<pre><code># Relative path (from current location)\ngraph(5v):/$ cd Alice\ngraph(5v):/Alice$ cd neighbors\n\n# Absolute path (from root)\ngraph(5v):/Alice/neighbors$ cd /Bob\nNow at: /Bob\n</code></pre>"},{"location":"shell/overview/#example-session","title":"Example Session","text":"<p>Here's a complete example session exploring a social network:</p> <pre><code>$ python3 -m AlgoGraph.shell.shell\n\nAlgoGraph Shell\nType 'help' for available commands, 'exit' to quit\n\nGraph loaded: 5 vertices, 4 edges\n\ngraph(5v):/$ ls\nAlice/  [2 neighbors]\nBob/  [2 neighbors]\nCharlie/  [1 neighbors]\nDiana/  [2 neighbors]\nEve/  [1 neighbors]\n\ngraph(5v):/$ cd Alice\n\ngraph(5v):/Alice$ info\nVertex: Alice\nDegree: 2\n\nAttributes:\n  age = 30\n  city = NYC\n\ngraph(5v):/Alice$ neighbors\nNeighbors of Alice:\n  Bob &lt;-&gt; (weight: 1.0)\n  Charlie &lt;-&gt; (weight: 1.0)\n\ngraph(5v):/Alice$ cd neighbors\n\ngraph(5v):/Alice/neighbors$ ls\nBob/  &lt;-&gt; [weight: 1.0]\nCharlie/  &lt;-&gt; [weight: 1.0]\n\ngraph(5v):/Alice/neighbors$ cd Bob\n\ngraph(5v):/Bob$ info\nVertex: Bob\nDegree: 2\n\nAttributes:\n  age = 25\n  city = Boston\n\ngraph(5v):/Bob$ cd /\n\ngraph(5v):/$ path Alice Eve\nPath found: Alice -&gt; Bob -&gt; Diana -&gt; Eve\nLength: 3 edges\n\ngraph(5v):/$ shortest Alice Eve\nShortest path: Alice -&gt; Bob -&gt; Diana -&gt; Eve\nDistance: 3.0\n\ngraph(5v):/$ components\nConnected components: 1\n\nComponent 1 (5 vertices):\n  Alice, Bob, Charlie, Diana, Eve\n\ngraph(5v):/$ save social_network.json\nGraph saved to social_network.json\n\ngraph(5v):/$ exit\nGoodbye!\n</code></pre>"},{"location":"shell/overview/#getting-help","title":"Getting Help","text":""},{"location":"shell/overview/#help-command","title":"help Command","text":"<p>Show available commands:</p> <pre><code>graph(5v):/$ help\n\nAlgoGraph Shell Commands:\n\nNavigation:\n  cd &lt;vertex&gt;     - Navigate to a vertex (relative)\n  cd /vertex      - Navigate to a vertex (absolute path)\n  cd neighbors    - View neighbors of current vertex\n  cd ..           - Go up one level\n  cd / or cd      - Go to root\n  ls              - List contents of current location\n  pwd             - Print current path\n\nInformation:\n  info            - Show info about current vertex or graph\n  neighbors       - Show neighbors of current vertex\n  help            - Show this help message\n\nGraph Queries:\n  find &lt;vertex&gt;   - Find vertex in graph\n  path &lt;v1&gt; &lt;v2&gt;  - Find path between vertices\n  shortest &lt;v1&gt; &lt;v2&gt; - Find shortest path (weighted)\n  components      - Show connected components\n  bfs [start]     - Breadth-first search from vertex\n\nFile Operations:\n  save &lt;file&gt;     - Save graph to JSON file\n\nOther:\n  exit, quit      - Exit the shell\n\nTips:\n  - Use quotes for vertex names with spaces: cd \"Alice Smith\"\n  - Press TAB for command/vertex name completion\n  - Use UP/DOWN arrows for command history\n</code></pre>"},{"location":"shell/overview/#exiting-the-shell","title":"Exiting the Shell","text":"<p>Multiple ways to exit:</p> <pre><code>graph(5v):/$ exit\nGoodbye!\n\n# Or use quit\ngraph(5v):/$ quit\nGoodbye!\n\n# Or just q\ngraph(5v):/$ q\nGoodbye!\n\n# Or Ctrl+D\ngraph(5v):/$ &lt;Ctrl+D&gt;\nGoodbye!\n</code></pre>"},{"location":"shell/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Navigation Commands in detail</li> <li>Explore Query Commands for graph analysis</li> <li>Check out Advanced Features like tab completion and scripting</li> </ul>"},{"location":"user-guide/algorithms/","title":"Graph Algorithms","text":"<p>AlgoGraph provides 30+ graph algorithms organized into four categories. All algorithms work with immutable graphs and return new data structures without modifying the original graph.</p>"},{"location":"user-guide/algorithms/#algorithm-categories","title":"Algorithm Categories","text":""},{"location":"user-guide/algorithms/#traversal-algorithms","title":"Traversal Algorithms","text":"<ul> <li>DFS (Depth-First Search)</li> <li>BFS (Breadth-First Search)</li> <li>Topological Sort</li> <li>Cycle Detection</li> <li>Path Finding</li> </ul>"},{"location":"user-guide/algorithms/#shortest-path-algorithms","title":"Shortest Path Algorithms","text":"<ul> <li>Dijkstra's Algorithm</li> <li>Bellman-Ford Algorithm</li> <li>Floyd-Warshall Algorithm</li> <li>A* Search</li> </ul>"},{"location":"user-guide/algorithms/#connectivity-algorithms","title":"Connectivity Algorithms","text":"<ul> <li>Connected Components</li> <li>Strongly Connected Components</li> <li>Bipartite Checking</li> <li>Bridge Finding</li> <li>Articulation Points</li> <li>Diameter Calculation</li> </ul>"},{"location":"user-guide/algorithms/#spanning-tree-algorithms","title":"Spanning Tree Algorithms","text":"<ul> <li>Kruskal's Algorithm</li> <li>Prim's Algorithm</li> <li>Minimum Spanning Tree</li> </ul>"},{"location":"user-guide/algorithms/#importing-algorithms","title":"Importing Algorithms","text":"<p>All algorithms are in the <code>AlgoGraph.algorithms</code> module:</p> <pre><code># Import specific algorithms\nfrom AlgoGraph.algorithms import dfs, bfs, dijkstra\n\n# Import from submodules\nfrom AlgoGraph.algorithms.traversal import topological_sort\nfrom AlgoGraph.algorithms.shortest_path import bellman_ford\nfrom AlgoGraph.algorithms.connectivity import connected_components\nfrom AlgoGraph.algorithms.spanning_tree import kruskal\n\n# Import all from a category\nfrom AlgoGraph.algorithms.traversal import *\n</code></pre>"},{"location":"user-guide/algorithms/#traversal-algorithms_1","title":"Traversal Algorithms","text":""},{"location":"user-guide/algorithms/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":"<p>Explore as far as possible along each branch before backtracking:</p> <pre><code>from AlgoGraph import Graph, Edge, Vertex\nfrom AlgoGraph.algorithms import dfs\n\ng = Graph(\n    vertices={Vertex('A'), Vertex('B'), Vertex('C'), Vertex('D')},\n    edges={Edge('A', 'B'), Edge('A', 'C'), Edge('B', 'D')}\n)\n\n# Get DFS traversal order\norder = dfs(g, 'A')\nprint(order)  # ['A', 'B', 'D', 'C'] (exact order may vary)\n\n# DFS with callback\ndef visit(vertex_id):\n    print(f\"Visiting {vertex_id}\")\n\ndfs(g, 'A', visit=visit)\n</code></pre> <p>Variants: - <code>dfs_recursive</code>: Recursive implementation - <code>dfs_iterative</code>: Iterative implementation using explicit stack</p>"},{"location":"user-guide/algorithms/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":"<p>Explore all neighbors before moving to the next level:</p> <pre><code>from AlgoGraph.algorithms import bfs, bfs_levels\n\n# Get BFS traversal order\norder = bfs(g, 'A')\nprint(order)  # ['A', 'B', 'C', 'D']\n\n# Get BFS by levels\nlevels = bfs_levels(g, 'A')\nprint(levels)  # [['A'], ['B', 'C'], ['D']]\n</code></pre>"},{"location":"user-guide/algorithms/#topological-sort","title":"Topological Sort","text":"<p>Order vertices in a DAG so all edges go from earlier to later vertices:</p> <pre><code>from AlgoGraph.algorithms import topological_sort, has_cycle\n\n# Check if graph is a DAG\nif not has_cycle(g):\n    order = topological_sort(g)\n    print(f\"Topological order: {order}\")\nelse:\n    print(\"Graph has cycles - cannot topologically sort\")\n</code></pre> <p>Use cases: Task scheduling, build systems, course prerequisites</p>"},{"location":"user-guide/algorithms/#path-finding","title":"Path Finding","text":"<p>Find paths between vertices:</p> <pre><code>from AlgoGraph.algorithms import find_path, find_all_paths\n\n# Find any path\npath = find_path(g, 'A', 'D')\nprint(path)  # ['A', 'B', 'D']\n\n# Find all paths (can be expensive!)\nall_paths = find_all_paths(g, 'A', 'D')\nfor path in all_paths:\n    print(' -&gt; '.join(path))\n</code></pre>"},{"location":"user-guide/algorithms/#cycle-detection","title":"Cycle Detection","text":"<p>Check if a graph contains cycles:</p> <pre><code>from AlgoGraph.algorithms import has_cycle\n\nif has_cycle(g):\n    print(\"Graph contains at least one cycle\")\nelse:\n    print(\"Graph is acyclic (DAG)\")\n</code></pre>"},{"location":"user-guide/algorithms/#shortest-path-algorithms_1","title":"Shortest Path Algorithms","text":""},{"location":"user-guide/algorithms/#dijkstras-algorithm","title":"Dijkstra's Algorithm","text":"<p>Find shortest paths from a source vertex (non-negative weights only):</p> <pre><code>from AlgoGraph.algorithms import dijkstra, shortest_path, shortest_path_length\n\n# Get distances and predecessors\ndistances, predecessors = dijkstra(g, 'A')\n\nprint(f\"Distance from A to D: {distances['D']}\")\nprint(f\"Predecessor of D: {predecessors['D']}\")\n\n# Get the actual shortest path\npath = shortest_path(g, 'A', 'D')\nprint(f\"Shortest path: {' -&gt; '.join(path)}\")\n\n# Just get the distance\ndistance = shortest_path_length(g, 'A', 'D')\nprint(f\"Shortest distance: {distance}\")\n</code></pre> <p>Time Complexity: O((V + E) log V) with binary heap</p> <p>Use cases: Road networks, network routing, map applications</p>"},{"location":"user-guide/algorithms/#bellman-ford-algorithm","title":"Bellman-Ford Algorithm","text":"<p>Find shortest paths allowing negative edge weights (detects negative cycles):</p> <pre><code>from AlgoGraph.algorithms import bellman_ford\n\n# Can handle negative weights\ndistances, predecessors = bellman_ford(g, 'A')\n\nif distances is None:\n    print(\"Negative cycle detected!\")\nelse:\n    print(f\"Distances: {distances}\")\n</code></pre> <p>Time Complexity: O(VE)</p> <p>Use cases: Currency arbitrage, graphs with negative weights</p>"},{"location":"user-guide/algorithms/#floyd-warshall-algorithm","title":"Floyd-Warshall Algorithm","text":"<p>Find shortest paths between all pairs of vertices:</p> <pre><code>from AlgoGraph.algorithms import floyd_warshall, all_shortest_paths\n\n# Get distance matrix\ndistances = floyd_warshall(g)\n\n# Distance from any vertex to any other\nprint(f\"Distance from A to D: {distances['A']['D']}\")\nprint(f\"Distance from B to C: {distances['B']['C']}\")\n\n# Get all shortest paths from A to D\npaths = all_shortest_paths(g, 'A', 'D')\nfor path in paths:\n    print(' -&gt; '.join(path))\n</code></pre> <p>Time Complexity: O(V\u00b3)</p> <p>Use cases: All-pairs distances, transitive closure</p>"},{"location":"user-guide/algorithms/#a-search","title":"A* Search","text":"<p>Heuristic-based shortest path algorithm:</p> <pre><code>from AlgoGraph.algorithms import a_star\n\ndef heuristic(v1, v2):\n    \"\"\"Estimate distance between vertices.\"\"\"\n    # Example: Euclidean distance for points\n    p1 = graph.get_vertex(v1).get('coords', (0, 0))\n    p2 = graph.get_vertex(v2).get('coords', (0, 0))\n    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\npath = a_star(g, 'A', 'D', heuristic)\nprint(f\"A* path: {' -&gt; '.join(path)}\")\n</code></pre> <p>Use cases: Pathfinding in games, GPS navigation</p>"},{"location":"user-guide/algorithms/#connectivity-algorithms_1","title":"Connectivity Algorithms","text":""},{"location":"user-guide/algorithms/#connected-components","title":"Connected Components","text":"<p>Find all connected components in an undirected graph:</p> <pre><code>from AlgoGraph.algorithms import connected_components, is_connected\n\n# Get all components\ncomponents = connected_components(g)\nprint(f\"Number of components: {len(components)}\")\n\nfor i, component in enumerate(components, 1):\n    print(f\"Component {i}: {component}\")\n\n# Check if graph is fully connected\nif is_connected(g):\n    print(\"Graph is connected\")\nelse:\n    print(\"Graph has multiple components\")\n</code></pre> <p>Use cases: Network analysis, clustering, social networks</p>"},{"location":"user-guide/algorithms/#strongly-connected-components","title":"Strongly Connected Components","text":"<p>Find strongly connected components in directed graphs:</p> <pre><code>from AlgoGraph.algorithms import strongly_connected_components, is_strongly_connected\n\n# Get SCCs\nsccs = strongly_connected_components(g)\nprint(f\"Number of SCCs: {len(sccs)}\")\n\n# Check if strongly connected\nif is_strongly_connected(g):\n    print(\"Graph is strongly connected\")\n</code></pre> <p>Use cases: Web page ranking, dependency analysis</p>"},{"location":"user-guide/algorithms/#bipartite-checking","title":"Bipartite Checking","text":"<p>Check if a graph is bipartite (2-colorable):</p> <pre><code>from AlgoGraph.algorithms import is_bipartite\n\nbipartite, partition = is_bipartite(g)\n\nif bipartite:\n    set1, set2 = partition\n    print(f\"Graph is bipartite!\")\n    print(f\"Set 1: {set1}\")\n    print(f\"Set 2: {set2}\")\nelse:\n    print(\"Graph is not bipartite\")\n</code></pre> <p>Use cases: Matching problems, scheduling, assignment problems</p>"},{"location":"user-guide/algorithms/#bridges-and-articulation-points","title":"Bridges and Articulation Points","text":"<p>Find critical edges and vertices:</p> <pre><code>from AlgoGraph.algorithms import find_bridges, find_articulation_points\n\n# Find bridges (edges whose removal disconnects the graph)\nbridges = find_bridges(g)\nprint(f\"Bridges: {bridges}\")\n\n# Find articulation points (vertices whose removal disconnects the graph)\narticulation_points = find_articulation_points(g)\nprint(f\"Articulation points: {articulation_points}\")\n</code></pre> <p>Use cases: Network reliability, vulnerability analysis</p>"},{"location":"user-guide/algorithms/#tree-and-diameter","title":"Tree and Diameter","text":"<p>Check if graph is a tree and find its diameter:</p> <pre><code>from AlgoGraph.algorithms import is_tree, diameter\n\n# Check if graph is a tree\nif is_tree(g):\n    print(\"Graph is a tree\")\n\n    # Find diameter (longest shortest path)\n    d = diameter(g)\n    print(f\"Diameter: {d}\")\n</code></pre>"},{"location":"user-guide/algorithms/#spanning-tree-algorithms_1","title":"Spanning Tree Algorithms","text":""},{"location":"user-guide/algorithms/#kruskals-algorithm","title":"Kruskal's Algorithm","text":"<p>Find minimum spanning tree using edge-based approach:</p> <pre><code>from AlgoGraph.algorithms import kruskal, total_weight\n\n# Get MST\nmst = kruskal(g)\nprint(f\"MST has {mst.edge_count} edges\")\nprint(f\"Total weight: {total_weight(mst)}\")\n\n# Print MST edges\nfor edge in mst.edges:\n    print(f\"{edge.source} - {edge.target}: {edge.weight}\")\n</code></pre> <p>Time Complexity: O(E log E)</p>"},{"location":"user-guide/algorithms/#prims-algorithm","title":"Prim's Algorithm","text":"<p>Find minimum spanning tree using vertex-based approach:</p> <pre><code>from AlgoGraph.algorithms import prim\n\n# Get MST starting from vertex 'A'\nmst = prim(g, 'A')\nprint(f\"Total weight: {total_weight(mst)}\")\n</code></pre> <p>Time Complexity: O(E log V)</p>"},{"location":"user-guide/algorithms/#general-mst-functions","title":"General MST Functions","text":"<pre><code>from AlgoGraph.algorithms import minimum_spanning_tree, is_spanning_tree\n\n# Get MST (uses best algorithm automatically)\nmst = minimum_spanning_tree(g)\n\n# Check if a graph is a spanning tree of another\nif is_spanning_tree(mst, g):\n    print(\"Valid spanning tree\")\n</code></pre>"},{"location":"user-guide/algorithms/#algorithm-complexity-reference","title":"Algorithm Complexity Reference","text":"Algorithm Time Complexity Space Complexity Notes DFS O(V + E) O(V) Recursive uses call stack BFS O(V + E) O(V) Uses queue Topological Sort O(V + E) O(V) Only for DAGs Dijkstra O((V + E) log V) O(V) Non-negative weights Bellman-Ford O(VE) O(V) Handles negative weights Floyd-Warshall O(V\u00b3) O(V\u00b2) All-pairs shortest paths A* O(E) O(V) Depends on heuristic Connected Components O(V + E) O(V) Undirected graphs SCC (Tarjan's) O(V + E) O(V) Directed graphs Bipartite Check O(V + E) O(V) Uses BFS/DFS Bridges O(V + E) O(V) Uses DFS Articulation Points O(V + E) O(V) Uses DFS Kruskal's MST O(E log E) O(V) Union-find Prim's MST O(E log V) O(V) Priority queue"},{"location":"user-guide/algorithms/#choosing-the-right-algorithm","title":"Choosing the Right Algorithm","text":""},{"location":"user-guide/algorithms/#for-finding-paths","title":"For Finding Paths","text":"<ul> <li>Any path: Use <code>find_path</code> (DFS-based)</li> <li>Shortest path (unweighted): Use <code>bfs</code></li> <li>Shortest path (weighted, non-negative): Use <code>dijkstra</code></li> <li>Shortest path (with negative weights): Use <code>bellman_ford</code></li> <li>All-pairs shortest paths: Use <code>floyd_warshall</code></li> <li>Heuristic search: Use <code>a_star</code></li> </ul>"},{"location":"user-guide/algorithms/#for-graph-structure-analysis","title":"For Graph Structure Analysis","text":"<ul> <li>Check connectivity: Use <code>is_connected</code> or <code>connected_components</code></li> <li>Directed graph connectivity: Use <code>strongly_connected_components</code></li> <li>Find critical points: Use <code>find_bridges</code> and <code>find_articulation_points</code></li> <li>Check if tree: Use <code>is_tree</code></li> <li>Check 2-colorability: Use <code>is_bipartite</code></li> </ul>"},{"location":"user-guide/algorithms/#for-traversal","title":"For Traversal","text":"<ul> <li>Explore depth-first: Use <code>dfs</code></li> <li>Explore breadth-first: Use <code>bfs</code></li> <li>Level-by-level traversal: Use <code>bfs_levels</code></li> <li>Topological ordering: Use <code>topological_sort</code></li> </ul>"},{"location":"user-guide/algorithms/#for-spanning-trees","title":"For Spanning Trees","text":"<ul> <li>Minimum spanning tree: Use <code>kruskal</code> or <code>prim</code></li> <li>Just need total weight: Use <code>total_weight</code></li> </ul>"},{"location":"user-guide/algorithms/#performance-tips","title":"Performance Tips","text":"<ol> <li>Choose the right algorithm: Don't use Floyd-Warshall for single-source shortest paths</li> <li>Pre-filter graphs: Remove unnecessary vertices/edges before running algorithms</li> <li>Cache results: Many algorithms can be expensive - cache results when possible</li> <li>Use appropriate data structures: BFS is faster than Dijkstra for unweighted graphs</li> <li>Check preconditions: Ensure graph meets algorithm requirements (e.g., no cycles for topological sort)</li> </ol>"},{"location":"user-guide/algorithms/#next-steps","title":"Next Steps","text":"<ul> <li>See Examples for real-world use cases</li> <li>Check the API Reference for detailed algorithm documentation</li> <li>Try algorithms in the Interactive Shell</li> </ul>"},{"location":"user-guide/core-concepts/","title":"Core Concepts","text":"<p>Understanding AlgoGraph's core concepts will help you use the library effectively. This guide explains the fundamental principles and design decisions behind AlgoGraph.</p>"},{"location":"user-guide/core-concepts/#immutability","title":"Immutability","text":"<p>The most important concept in AlgoGraph is immutability: all data structures are immutable by default.</p>"},{"location":"user-guide/core-concepts/#what-is-immutability","title":"What is Immutability?","text":"<p>An immutable object cannot be changed after it's created. Instead of modifying an object, you create a new one with the desired changes.</p> <pre><code>from AlgoGraph import Vertex\n\n# Create a vertex\nv1 = Vertex('A', attrs={'value': 10})\n\n# \"Modify\" it (actually creates a new vertex)\nv2 = v1.with_attrs(value=20)\n\n# Original is unchanged\nprint(v1.get('value'))  # 10\nprint(v2.get('value'))  # 20\n</code></pre>"},{"location":"user-guide/core-concepts/#why-immutability","title":"Why Immutability?","text":"<ol> <li>Prevents Bugs: No accidental modifications to shared data</li> <li>Thread-Safe: Safe to use in concurrent code without locks</li> <li>Easier to Reason About: Data flow is explicit and predictable</li> <li>Enables Time Travel: Keep history of all graph states</li> <li>Simplifies Testing: No hidden state changes to track</li> </ol>"},{"location":"user-guide/core-concepts/#immutability-in-practice","title":"Immutability in Practice","text":"<p>All three core types are immutable:</p> <pre><code>from AlgoGraph import Vertex, Edge, Graph\n\n# Vertices are immutable\nv1 = Vertex('A')\nv2 = v1.with_attrs(x=10)  # New vertex\nv3 = v1.with_id('B')      # New vertex\n\n# Edges are immutable\ne1 = Edge('A', 'B', weight=5)\ne2 = e1.with_weight(10)         # New edge\ne3 = e1.to_undirected()         # New edge\n\n# Graphs are immutable\ng1 = Graph({v1}, {e1})\ng2 = g1.add_vertex(v2)    # New graph\ng3 = g1.add_edge(e2)      # New graph\n</code></pre>"},{"location":"user-guide/core-concepts/#the-three-core-types","title":"The Three Core Types","text":"<p>AlgoGraph has three fundamental data types:</p>"},{"location":"user-guide/core-concepts/#vertex","title":"Vertex","text":"<p>A Vertex (or node) represents a point in the graph. Each vertex has:</p> <ul> <li>ID (string): Unique identifier</li> <li>Attributes (dict): Arbitrary key-value pairs</li> </ul> <pre><code># Simple vertex\nv = Vertex('London')\n\n# Vertex with attributes\nv = Vertex('London', attrs={\n    'population': 9000000,\n    'country': 'UK',\n    'coordinates': (51.5074, -0.1278)\n})\n\n# Access attributes\nv.get('population')           # 9000000\nv.get('timezone', 'UTC')      # 'UTC' (default)\n</code></pre> <p>Vertices are compared by ID and attributes:</p> <pre><code>v1 = Vertex('A', attrs={'x': 1})\nv2 = Vertex('A', attrs={'x': 1})\nv3 = Vertex('A', attrs={'x': 2})\n\nv1 == v2  # True (same ID and attributes)\nv1 == v3  # False (different attributes)\n</code></pre>"},{"location":"user-guide/core-concepts/#edge","title":"Edge","text":"<p>An Edge connects two vertices. Each edge has:</p> <ul> <li>Source (string): Source vertex ID</li> <li>Target (string): Target vertex ID</li> <li>Directed (bool): Whether the edge is directed (default: True)</li> <li>Weight (float): Edge weight (default: 1.0)</li> <li>Attributes (dict): Arbitrary key-value pairs</li> </ul> <pre><code># Simple directed edge\ne = Edge('A', 'B')\n\n# Undirected edge\ne = Edge('A', 'B', directed=False)\n\n# Weighted edge\ne = Edge('A', 'B', weight=5.0)\n\n# Edge with attributes\ne = Edge('A', 'B', weight=100, attrs={\n    'road_type': 'highway',\n    'speed_limit': 65\n})\n</code></pre> <p>Directed vs. undirected edges:</p> <pre><code>directed = Edge('A', 'B', directed=True)\ndirected.connects('A', 'B')  # True\ndirected.connects('B', 'A')  # False\n\nundirected = Edge('A', 'B', directed=False)\nundirected.connects('A', 'B')  # True\nundirected.connects('B', 'A')  # True (order doesn't matter)\n</code></pre>"},{"location":"user-guide/core-concepts/#graph","title":"Graph","text":"<p>A Graph is a collection of vertices and edges. It provides:</p> <ul> <li>Vertices: Set of Vertex objects</li> <li>Edges: Set of Edge objects</li> <li>Operations: Methods for querying and transforming the graph</li> </ul> <pre><code># Empty graph\ng = Graph()\n\n# Graph with vertices and edges\ng = Graph(\n    vertices={Vertex('A'), Vertex('B'), Vertex('C')},\n    edges={Edge('A', 'B'), Edge('B', 'C')}\n)\n\n# Query the graph\ng.vertex_count  # 3\ng.edge_count    # 2\ng.has_vertex('A')      # True\ng.has_edge('A', 'B')   # True\ng.neighbors('A')       # {'B'}\ng.degree('B')          # 2 (one in, one out)\n</code></pre>"},{"location":"user-guide/core-concepts/#separation-of-data-and-algorithms","title":"Separation of Data and Algorithms","text":"<p>AlgoGraph separates data structures from algorithms:</p> <ul> <li>Data structures (<code>Vertex</code>, <code>Edge</code>, <code>Graph</code>) live in the main module</li> <li>Algorithms (DFS, BFS, Dijkstra, etc.) live in <code>AlgoGraph.algorithms</code></li> </ul> <p>This separation provides several benefits:</p> <ol> <li>Modularity: Import only what you need</li> <li>Testability: Easy to test data and algorithms separately</li> <li>Extensibility: Add new algorithms without changing data structures</li> <li>Clarity: Clear distinction between \"what\" (data) and \"how\" (algorithms)</li> </ol> <pre><code># Data structures\nfrom AlgoGraph import Vertex, Edge, Graph\n\n# Algorithms (separate import)\nfrom AlgoGraph.algorithms import dijkstra, bfs, connected_components\n\n# Use together\ng = Graph(...)\ndistances, predecessors = dijkstra(g, 'A')\ncomponents = connected_components(g)\n</code></pre>"},{"location":"user-guide/core-concepts/#graph-modifications","title":"Graph Modifications","text":"<p>Since graphs are immutable, \"modifications\" return new graphs:</p> <pre><code>g1 = Graph({Vertex('A')}, {})\n\n# Each operation returns a new graph\ng2 = g1.add_vertex(Vertex('B'))\ng3 = g2.add_edge(Edge('A', 'B'))\ng4 = g3.remove_vertex('A')\n\n# Original is unchanged\nprint(g1.vertex_count)  # 1\nprint(g4.vertex_count)  # 1 (just 'B' now)\n\n# Can chain operations\ng5 = (Graph()\n    .add_vertex(Vertex('A'))\n    .add_vertex(Vertex('B'))\n    .add_edge(Edge('A', 'B'))\n)\n</code></pre>"},{"location":"user-guide/core-concepts/#type-system","title":"Type System","text":"<p>AlgoGraph uses Python's type hints throughout:</p> <pre><code>from typing import Set, Dict, Optional\n\ndef process_graph(\n    graph: Graph,\n    start: str,\n    threshold: float = 1.0\n) -&gt; Optional[Set[str]]:\n    \"\"\"Process graph and return matching vertices.\"\"\"\n    # Type hints help IDEs and type checkers\n    ...\n</code></pre> <p>Benefits:</p> <ul> <li>IDE Support: Better autocomplete and error detection</li> <li>Documentation: Types document expected inputs/outputs</li> <li>Type Checking: Use <code>mypy</code> to catch errors before runtime</li> </ul>"},{"location":"user-guide/core-concepts/#vertex-and-edge-identity","title":"Vertex and Edge Identity","text":""},{"location":"user-guide/core-concepts/#vertex-identity","title":"Vertex Identity","text":"<p>Vertices are identified by their ID. Two vertices with the same ID are considered the same vertex (even with different attributes):</p> <pre><code>v1 = Vertex('A', attrs={'x': 1})\nv2 = Vertex('A', attrs={'x': 2})\n\n# Same ID, so same hash (for use in sets)\nhash(v1) == hash(v2)  # True\n\n# But different equality (attributes differ)\nv1 == v2  # False\n</code></pre> <p>This means you can't have two different vertices with the same ID in a graph:</p> <pre><code>g = Graph({\n    Vertex('A', attrs={'x': 1}),\n    Vertex('A', attrs={'x': 2}),  # This replaces the first one\n})\ng.vertex_count  # 1 (not 2)\n</code></pre>"},{"location":"user-guide/core-concepts/#edge-identity","title":"Edge Identity","text":"<p>Edges are identified by their source, target, and direction:</p> <pre><code>e1 = Edge('A', 'B', directed=True)\ne2 = Edge('A', 'B', directed=True)\ne3 = Edge('A', 'B', directed=False)\n\n# Directed edges: same source/target = same identity\nhash(e1) == hash(e2)  # True\nhash(e1) == hash(e3)  # False (different direction)\n\n# Undirected edges: order doesn't matter for hash\ne4 = Edge('A', 'B', directed=False)\ne5 = Edge('B', 'A', directed=False)\nhash(e4) == hash(e5)  # True\n</code></pre>"},{"location":"user-guide/core-concepts/#graph-types","title":"Graph Types","text":"<p>AlgoGraph supports various graph types:</p>"},{"location":"user-guide/core-concepts/#directed-vs-undirected","title":"Directed vs. Undirected","text":"<pre><code># Directed graph (default)\ndirected = Graph(\n    vertices={Vertex('A'), Vertex('B')},\n    edges={Edge('A', 'B', directed=True)}\n)\n\n# Undirected graph\nundirected = Graph(\n    vertices={Vertex('A'), Vertex('B')},\n    edges={Edge('A', 'B', directed=False)}\n)\n\n# Mixed graph (both types of edges)\nmixed = Graph(\n    vertices={Vertex('A'), Vertex('B'), Vertex('C')},\n    edges={\n        Edge('A', 'B', directed=True),\n        Edge('B', 'C', directed=False),\n    }\n)\n</code></pre>"},{"location":"user-guide/core-concepts/#weighted-vs-unweighted","title":"Weighted vs. Unweighted","text":"<pre><code># Unweighted (all weights = 1.0)\nunweighted = Graph(edges={\n    Edge('A', 'B'),  # weight defaults to 1.0\n    Edge('B', 'C'),\n})\n\n# Weighted\nweighted = Graph(edges={\n    Edge('A', 'B', weight=5.0),\n    Edge('B', 'C', weight=3.0),\n})\n</code></pre>"},{"location":"user-guide/core-concepts/#special-graph-types","title":"Special Graph Types","text":"<p>You can model any graph type using AlgoGraph:</p> <ul> <li>Simple graphs: No self-loops, no parallel edges</li> <li>Multigraphs: Multiple edges between same vertices (use edge attributes to distinguish)</li> <li>Trees: Connected acyclic graphs</li> <li>DAGs: Directed acyclic graphs</li> <li>Bipartite graphs: Two disjoint vertex sets</li> <li>Complete graphs: Every vertex connected to every other</li> </ul>"},{"location":"user-guide/core-concepts/#attributes","title":"Attributes","text":"<p>Both vertices and edges can have arbitrary attributes:</p> <pre><code># Vertex attributes\nperson = Vertex('Alice', attrs={\n    'age': 30,\n    'email': 'alice@example.com',\n    'tags': ['developer', 'team-lead'],\n    'metadata': {'joined': '2020-01-01'}\n})\n\n# Edge attributes\nroad = Edge('Boston', 'NYC', weight=215, attrs={\n    'road_type': 'Interstate',\n    'route': 'I-90',\n    'toll': True,\n    'scenic_rating': 7\n})\n</code></pre> <p>Attributes are stored as dictionaries and can be any JSON-serializable type.</p>"},{"location":"user-guide/core-concepts/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/core-concepts/#building-graphs-incrementally","title":"Building Graphs Incrementally","text":"<pre><code># Start empty\ng = Graph()\n\n# Add vertices one by one\nfor name in ['A', 'B', 'C']:\n    g = g.add_vertex(Vertex(name))\n\n# Add edges\ng = g.add_edge(Edge('A', 'B'))\ng = g.add_edge(Edge('B', 'C'))\n</code></pre>"},{"location":"user-guide/core-concepts/#building-from-collections","title":"Building from Collections","text":"<pre><code># From lists\nvertices = [Vertex(name) for name in ['A', 'B', 'C']]\nedges = [Edge(src, tgt) for src, tgt in [('A', 'B'), ('B', 'C')]]\ng = Graph(set(vertices), set(edges))\n\n# From comprehensions\ng = Graph(\n    vertices={Vertex(str(i)) for i in range(5)},\n    edges={Edge(str(i), str(i+1)) for i in range(4)}\n)\n</code></pre>"},{"location":"user-guide/core-concepts/#transforming-graphs","title":"Transforming Graphs","text":"<pre><code># Add attributes to all vertices\ndef label_vertices(graph):\n    new_graph = graph\n    for v in graph.vertices:\n        updated = v.with_attrs(label=f\"Node {v.id}\")\n        new_graph = new_graph.update_vertex(updated)\n    return new_graph\n\n# Filter vertices by predicate\nhigh_degree = graph.find_vertices(lambda v: graph.degree(v.id) &gt; 3)\n\n# Extract subgraph\nvertex_ids = {v.id for v in high_degree}\nsubgraph = graph.subgraph(vertex_ids)\n</code></pre>"},{"location":"user-guide/core-concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the core concepts, learn about:</p> <ul> <li>Working with Vertices</li> <li>Working with Edges</li> <li>Building Graphs</li> <li>Graph Algorithms</li> </ul>"},{"location":"user-guide/vertices/","title":"Working with Vertices","text":"<p>Vertices (also called nodes) are the fundamental building blocks of graphs. This guide covers everything you need to know about creating and using vertices in AlgoGraph.</p>"},{"location":"user-guide/vertices/#creating-vertices","title":"Creating Vertices","text":""},{"location":"user-guide/vertices/#basic-vertices","title":"Basic Vertices","text":"<p>The simplest vertex has just an ID:</p> <pre><code>from AlgoGraph import Vertex\n\nv = Vertex('A')\nprint(v.id)  # 'A'\n</code></pre> <p>Vertex IDs must be strings:</p> <pre><code># Valid\nv1 = Vertex('node1')\nv2 = Vertex('Alice')\nv3 = Vertex('city_42')\n\n# If you have non-string IDs, convert them\nv4 = Vertex(str(42))  # Integer to string\nv5 = Vertex(str(uuid.uuid4()))  # UUID to string\n</code></pre>"},{"location":"user-guide/vertices/#vertices-with-attributes","title":"Vertices with Attributes","text":"<p>Add arbitrary attributes as a dictionary:</p> <pre><code># Person vertex\nperson = Vertex('Alice', attrs={\n    'age': 30,\n    'city': 'NYC',\n    'occupation': 'Engineer'\n})\n\n# City vertex\ncity = Vertex('NYC', attrs={\n    'population': 8336000,\n    'country': 'USA',\n    'coordinates': (40.7128, -74.0060)\n})\n\n# Generic data vertex\ndata = Vertex('node1', attrs={\n    'value': 42,\n    'timestamp': '2025-01-15T10:30:00',\n    'tags': ['important', 'verified'],\n    'metadata': {'source': 'api', 'confidence': 0.95}\n})\n</code></pre> <p>Attribute Types</p> <p>Attributes can be any JSON-serializable type: strings, numbers, booleans, lists, dicts, null. Avoid non-serializable types like functions or custom objects if you plan to save graphs to JSON.</p>"},{"location":"user-guide/vertices/#accessing-vertex-data","title":"Accessing Vertex Data","text":""},{"location":"user-guide/vertices/#get-the-id","title":"Get the ID","text":"<pre><code>v = Vertex('London', attrs={'country': 'UK'})\nprint(v.id)  # 'London'\n</code></pre>"},{"location":"user-guide/vertices/#get-attributes","title":"Get Attributes","text":"<p>Use the <code>get()</code> method (like a dictionary):</p> <pre><code>v = Vertex('Alice', attrs={'age': 30, 'city': 'NYC'})\n\n# Get attribute value\nage = v.get('age')  # 30\ncity = v.get('city')  # 'NYC'\n\n# Get with default value\nemail = v.get('email', 'N/A')  # 'N/A' (not present)\n\n# Access the full attrs dict\nprint(v.attrs)  # {'age': 30, 'city': 'NYC'}\n</code></pre> <p>Don't Modify attrs Directly</p> <p>Even though you can access <code>v.attrs</code>, don't modify it directly: <pre><code># BAD - will raise an error (frozen dataclass)\nv.attrs['age'] = 31  # Error!\n\n# GOOD - create new vertex with updated attributes\nv2 = v.with_attrs(age=31)\n</code></pre></p>"},{"location":"user-guide/vertices/#modifying-vertices-immutably","title":"Modifying Vertices (Immutably)","text":"<p>Since vertices are immutable, \"modifying\" a vertex creates a new one:</p>"},{"location":"user-guide/vertices/#add-or-update-attributes","title":"Add or Update Attributes","text":"<pre><code>v1 = Vertex('Alice', attrs={'age': 30})\n\n# Add new attribute\nv2 = v1.with_attrs(city='NYC')\nprint(v2.attrs)  # {'age': 30, 'city': 'NYC'}\n\n# Update existing attribute\nv3 = v1.with_attrs(age=31)\nprint(v3.attrs)  # {'age': 31}\n\n# Add multiple attributes\nv4 = v1.with_attrs(age=31, city='NYC', job='Engineer')\nprint(v4.attrs)  # {'age': 31, 'city': 'NYC', 'job': 'Engineer'}\n\n# Original is unchanged\nprint(v1.attrs)  # {'age': 30}\n</code></pre>"},{"location":"user-guide/vertices/#remove-attributes","title":"Remove Attributes","text":"<pre><code>v1 = Vertex('Alice', attrs={'age': 30, 'city': 'NYC', 'job': 'Engineer'})\n\n# Remove one attribute\nv2 = v1.without_attrs('job')\nprint(v2.attrs)  # {'age': 30, 'city': 'NYC'}\n\n# Remove multiple attributes\nv3 = v1.without_attrs('city', 'job')\nprint(v3.attrs)  # {'age': 30}\n\n# Remove non-existent attribute (no error)\nv4 = v1.without_attrs('email')  # No change\n</code></pre>"},{"location":"user-guide/vertices/#change-vertex-id","title":"Change Vertex ID","text":"<pre><code>v1 = Vertex('Alice', attrs={'age': 30})\n\n# Create vertex with new ID (keeps attributes)\nv2 = v1.with_id('Alice_Smith')\nprint(v2.id)     # 'Alice_Smith'\nprint(v2.attrs)  # {'age': 30}\n</code></pre>"},{"location":"user-guide/vertices/#vertex-comparison","title":"Vertex Comparison","text":""},{"location":"user-guide/vertices/#equality","title":"Equality","text":"<p>Vertices are equal if they have the same ID and attributes:</p> <pre><code>v1 = Vertex('A', attrs={'x': 1})\nv2 = Vertex('A', attrs={'x': 1})\nv3 = Vertex('A', attrs={'x': 2})\nv4 = Vertex('B', attrs={'x': 1})\n\nv1 == v2  # True (same ID and attrs)\nv1 == v3  # False (same ID, different attrs)\nv1 == v4  # False (different ID)\n</code></pre>"},{"location":"user-guide/vertices/#hashing","title":"Hashing","text":"<p>Vertices are hashable (can be used in sets and as dict keys). The hash is based on the ID only:</p> <pre><code>v1 = Vertex('A', attrs={'x': 1})\nv2 = Vertex('A', attrs={'x': 2})\n\n# Same hash (same ID)\nhash(v1) == hash(v2)  # True\n\n# Can put in sets\nvertices = {v1, v2}\nlen(vertices)  # 1 (only one 'A' vertex in set)\n</code></pre> <p>Set Behavior</p> <p>When vertices with the same ID are in a set, only one is kept: <pre><code>vertices = {\n    Vertex('A', attrs={'x': 1}),\n    Vertex('A', attrs={'x': 2}),  # Replaces the first one\n}\n# The set contains just one vertex, but which attrs it has is undefined\n</code></pre></p>"},{"location":"user-guide/vertices/#string-representation","title":"String Representation","text":"<p>Vertices have helpful string representations:</p> <pre><code>v1 = Vertex('A')\nv2 = Vertex('Alice', attrs={'age': 30, 'city': 'NYC'})\n\n# repr() shows full details\nprint(repr(v1))  # Vertex('A')\nprint(repr(v2))  # Vertex('Alice', age=30, city='NYC')\n\n# str() shows just the ID\nprint(str(v1))  # A\nprint(str(v2))  # Alice\n\n# Useful in f-strings\nprint(f\"Processing {v2}\")  # Processing Alice\n</code></pre>"},{"location":"user-guide/vertices/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/vertices/#creating-vertices-from-data","title":"Creating Vertices from Data","text":"<pre><code># From a list of names\nnames = ['Alice', 'Bob', 'Charlie']\nvertices = {Vertex(name) for name in names}\n\n# From a dictionary\ndata = {\n    'Alice': {'age': 30, 'city': 'NYC'},\n    'Bob': {'age': 25, 'city': 'Boston'},\n}\nvertices = {Vertex(name, attrs=attrs) for name, attrs in data.items()}\n\n# From CSV or database\nimport csv\n\nwith open('people.csv') as f:\n    reader = csv.DictReader(f)\n    vertices = {\n        Vertex(row['id'], attrs={\n            'name': row['name'],\n            'age': int(row['age']),\n        })\n        for row in reader\n    }\n</code></pre>"},{"location":"user-guide/vertices/#filtering-vertices","title":"Filtering Vertices","text":"<pre><code>from AlgoGraph import Graph\n\ng = Graph({\n    Vertex('Alice', attrs={'age': 30, 'city': 'NYC'}),\n    Vertex('Bob', attrs={'age': 25, 'city': 'Boston'}),\n    Vertex('Carol', attrs={'age': 35, 'city': 'NYC'}),\n})\n\n# Find vertices by attribute\nnyc_residents = g.find_vertices(lambda v: v.get('city') == 'NYC')\n# {Vertex('Alice', ...), Vertex('Carol', ...)}\n\n# Find vertices by age\nseniors = g.find_vertices(lambda v: v.get('age', 0) &gt;= 30)\n\n# Find vertices with specific attribute present\nhas_email = g.find_vertices(lambda v: 'email' in v.attrs)\n</code></pre>"},{"location":"user-guide/vertices/#transforming-vertex-attributes","title":"Transforming Vertex Attributes","text":"<pre><code># Add a computed attribute to all vertices\ndef add_generation(vertex):\n    \"\"\"Add generation based on age.\"\"\"\n    age = vertex.get('age', 0)\n    if age &lt; 30:\n        generation = 'young'\n    elif age &lt; 50:\n        generation = 'middle'\n    else:\n        generation = 'senior'\n    return vertex.with_attrs(generation=generation)\n\n# Apply to all vertices in graph\nnew_graph = graph\nfor v in graph.vertices:\n    updated = add_generation(v)\n    new_graph = new_graph.update_vertex(updated)\n</code></pre>"},{"location":"user-guide/vertices/#batch-vertex-operations","title":"Batch Vertex Operations","text":"<pre><code># Create many vertices at once\nvertices = {\n    Vertex(f'node_{i}', attrs={'value': i * 10})\n    for i in range(100)\n}\n\n# Update multiple vertices\ngraph = Graph(vertices)\nupdated_graph = graph\nfor v in graph.vertices:\n    if v.get('value', 0) &gt; 500:\n        updated = v.with_attrs(priority='high')\n        updated_graph = updated_graph.update_vertex(updated)\n</code></pre>"},{"location":"user-guide/vertices/#using-vertices-with-special-names","title":"Using Vertices with Special Names","text":"<p>Vertex IDs can contain any characters, including spaces and special characters:</p> <pre><code># Spaces in names\nv1 = Vertex('Alice Smith')\nv2 = Vertex('New York City')\n\n# Special characters\nv3 = Vertex('item-42')\nv4 = Vertex('user@example.com')\nv5 = Vertex('node_with_underscores')\n\n# Unicode\nv6 = Vertex('Fran\u00e7ois')\nv7 = Vertex('\u6771\u4eac')\n</code></pre> <p>When using the interactive shell with special names, use quotes:</p> <pre><code>cd \"Alice Smith\"\ncd \"New York City\"\n</code></pre>"},{"location":"user-guide/vertices/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/vertices/#1-choose-meaningful-ids","title":"1. Choose Meaningful IDs","text":"<p>Use descriptive IDs that make sense in your domain:</p> <pre><code># Good\nVertex('London')\nVertex('user_12345')\nVertex('transaction_abc123')\n\n# Less ideal\nVertex('1')\nVertex('x')\nVertex('temp')\n</code></pre>"},{"location":"user-guide/vertices/#2-keep-attributes-flat-when-possible","title":"2. Keep Attributes Flat When Possible","text":"<p>Flat attributes are easier to query:</p> <pre><code># Good\nVertex('Alice', attrs={\n    'first_name': 'Alice',\n    'last_name': 'Smith',\n    'age': 30,\n    'city': 'NYC'\n})\n\n# Can work but harder to query\nVertex('Alice', attrs={\n    'name': {'first': 'Alice', 'last': 'Smith'},\n    'location': {'city': 'NYC', 'zip': '10001'}\n})\n</code></pre>"},{"location":"user-guide/vertices/#3-use-consistent-attribute-names","title":"3. Use Consistent Attribute Names","text":"<p>Standardize attribute names across vertices:</p> <pre><code># Good - consistent naming\nVertex('Alice', attrs={'age': 30, 'city': 'NYC'})\nVertex('Bob', attrs={'age': 25, 'city': 'Boston'})\n\n# Confusing - inconsistent naming\nVertex('Alice', attrs={'age': 30, 'city': 'NYC'})\nVertex('Bob', attrs={'years_old': 25, 'location': 'Boston'})\n</code></pre>"},{"location":"user-guide/vertices/#4-validate-attribute-values","title":"4. Validate Attribute Values","text":"<p>Add validation when creating vertices from external data:</p> <pre><code>def create_person_vertex(id: str, age: int, city: str) -&gt; Vertex:\n    \"\"\"Create a person vertex with validation.\"\"\"\n    if not id:\n        raise ValueError(\"ID cannot be empty\")\n    if age &lt; 0 or age &gt; 150:\n        raise ValueError(f\"Invalid age: {age}\")\n    if not city:\n        raise ValueError(\"City cannot be empty\")\n\n    return Vertex(id, attrs={'age': age, 'city': city})\n</code></pre>"},{"location":"user-guide/vertices/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Working with Edges</li> <li>See how to Build Graphs</li> <li>Explore Graph Algorithms</li> </ul>"}]}